
# `nikita.docker.build(options, [callback])`

Build docker repository from Dockerfile, from content or from current working
directory (exclusive options).

The user can choose whether the build is local or on the remote.
Options are the same than docker build command with nikita's one.
Be aware than you can not use ADD with content option because docker build
from STDIN does not support a context.

By default docker always run the build and overwrite existing repositories.
Status unmodified if the repository is identical to a previous one

## Options

* `boot2docker` (boolean)   
  Whether to use boot2docker or not, default to false.
* `image` (string)   
  Name of the image, required.
* `tag` (string)   
  Tag of the image.
* `machine` (string)   
  Name of the docker-machine, required if using docker-machine.
* `file`   
  Path to Dockerfile.
* `content` (string | [string])   
  Use this text to build the repository.
* `quiet` (boolean)   
  Suppress the verbose output generated by the containers. Default to false
* `rm` (boolean)   
  Remove intermediate containers after build, default to true.
* `force_rm` (boolean)   
  Always remove intermediate containers during build, default to false.
* `no_cache` (boolean)   
  Do not use cache when building the repository, default to false.
* `build_arg` ("k=v" | [])   
  Send arguments to the build (Must match an ARG command).
* `cwd` (string)   
  change the working directory for the build.

## Callback parameters

* `err`   
  Error object if any.   
* `status`   
  True if image was successfully built.   
* `image`   
  Image ID if the image was built, the ID is based on the image sha256 checksum.   
* `stdout`   
  Stdout value(s) unless `stdout` option is provided.   
* `stderr`   
  Stderr value(s) unless `stderr` option is provided.   

## Example

### Builds a repository from dockerfile without any resourcess

```javascript
nikita.docker.build({
  image: 'ryba/targe-build',
  source: '/home/ryba/Dockerfile'
}, function(err, status, stdout, stderr){
  console.log( err ? err.message : 'Container built: ' + status);
});
```

### Builds an repository from dockerfile with external resources

In this case nikita download all the external files into a resources directory in the same location
than the Dockerfile. The Dockerfile content:

```dockerfile
FROM centos7
ADD resources/package.tar.gz /tmp/
ADD resources/configuration.sh /tmp/
```

Build directory tree :

```
├── Dockerfile
├── resources
│   ├── package.tar.gz
│   ├── configuration.sh
```

```javascript
nikita.docker.build({
  ssh: ssh
  tag: 'ryba/target-build'
  source: '/home/ryba/Dockerfile'
  resources: ['http://url.com/package.tar.gz/','/home/configuration.sh']
}, function(err, status, stdout, stderr){
  console.log( err ? err.message : 'Container built: ' + status);
});
```

### Builds an repository from stdin

```javascript
nikita.docker.build({
  ssh: ssh,
  tag: 'ryba/target-build'
  content: "FROM ubuntu\nRUN echo 'helloworld'"
}, function(err, is_built, stdout, stderr){
  console.log( err ? err.message : 'Container built: ' + status);
});
```

## Source Code

    module.exports = (options, callback) ->
      @log message: "Entering Docker build", level: 'DEBUG', module: 'nikita/lib/docker/build'
      # SSH connection
      ssh = @ssh options.ssh
      # Global options
      options.docker ?= {}
      options[k] ?= v for k, v of options.docker
      # Validation
      return callback Error 'Required option "image"' unless options.image?
      return callback Error 'Can not build from Dockerfile and content' if options.content? and options.file?
      options.rm ?= true
      cmd = 'build'
      number_of_step = 0
      userargs = []
      # status unmodified if final tag already exists
      dockerfile_cmds = ['CMD','LABEL','EXPOSE','ENV','ADD','COPY','ENTRYPOINT',
       'VOLUME','USER','WORKDIR','ARG','ONBUILD','RUN','STOPSIGNAL','MAINTAINER']
      source = null
      if options.file
        source = options.file
      else if options.cwd
        source = "#{options.cwd}/Dockerfile"
      options.cwd ?= path.dirname options.file if options.file
      # Apply search and replace to content
      # options.write ?= []
      # if options.from? or options.to? or options.match? or options.replace? or options.before?
      #   options.write.push
      #     from: options.from
      #     to: options.to
      #     match: options.match
      #     replace: options.replace
      #     append: options.append
      #     before: options.before
      #   options.append = false
      # Build cmd
      for opt in ['force_rm', 'quiet', 'no_cache']
        cmd += " --#{opt.replace '_', '-'}" if options[opt]
      for opt in ['build_arg'] then if options[opt]?
        if Array.isArray options[opt]
          cmd += " --#{opt.replace '_', '-'} #{k}" for k in options[opt]
        else
          cmd += " --#{opt.replace '_', '-'} #{options[opt]}"
      cmd += " --rm=#{if options.rm then 'true' else 'false'}"
      cmd += " -t \"#{options.image}#{if options.tag then ":#{options.tag}" else ''}\""
      # custom command for content option0
      options.file ?= path.resolve options.cwd, 'Dockerfile' if options.cwd
      if options.content?
        @log message: "Building from text: Docker won't have a context. ADD/COPY not working", level: 'WARN', module: 'nikita/docker/build'
        cmd += " - <<DOCKERFILE\n#{options.content}\nDOCKERFILE" if options.content?
      else if options.file?
        @log message: "Building from Dockerfile: \"#{options.file}\"", level: 'INFO', module: 'nikita/docker/build'
        cmd += " -f #{options.file} #{options.cwd}"
      else
        @log message: "Building from CWD", level: 'INFO', module: 'nikita/docker/build'
        cmd += ' .'
      @file
        if: options.content
        content: options.content
        source: source
        target: (content) ->
          options.content = content
        from: options.from
        to: options.to
        match: options.match
        replace: options.replace
        append: options.append
        before: options.before
        write: options.write
      @call # Read Dockerfile if necessary to count steps
        unless: options.content
      , (_, callback) ->
        @log message: "Reading Dockerfile from : #{options.file}", level: 'INFO', module: 'nikita/lib/build'
        @fs.readFile ssh: options.ssh, target: options.file, encoding: 'utf8', (err, {data}) ->
          return callback err if err
          options.content = data
          callback()
      @call -> # Count steps
        for line in string.lines options.content
          number_of_step++ if /^(.*?)\s/.exec(line)?[1] in dockerfile_cmds
      @system.execute
        cmd: docker.wrap options, cmd
        cwd: options.cwd
      , (err, {stdout, stderr}) ->
        throw err if err
        image_id = null
        # lines = string.lines stderr
        lines = string.lines stdout
        number_of_cache = 0
        for k,  line of lines
          if (line.indexOf('Using cache') isnt  -1 )
            number_of_cache = number_of_cache + 1
          if (line.indexOf('Successfully built') isnt  -1 )
            image_id = line.split(' ').pop().toString()
        userargs =
          status: number_of_step isnt number_of_cache
          image: image_id
          stdout: stdout
          stderr: stderr
      @next (err) ->
        return callback err if err
        @log if userargs.status
        then message: "New image id #{userargs[1]}", level: 'INFO', module: 'nikita/lib/docker/build' 
        else message: "Identical image id #{userargs[1]}", level: 'INFO', module: 'nikita/lib/docker/build'
        callback null, userargs

## Modules Dependencies

    docker = require '../misc/docker'
    string = require '../misc/string'
    path = require 'path'
    util = require 'util'
    {merge} = require '../misc'
