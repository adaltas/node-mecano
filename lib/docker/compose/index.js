// Generated by CoffeeScript 2.3.1
// # `nikita.docker.compose(options, [callback])`

// Create and start containers according to a docker-compose file
// `nikita.docker.compose` is an alias to `nikita.docker.compose.up`

// ## Options

// * `boot2docker` (boolean)   
//   Whether to use boot2docker or not, default to false.
// * `machine` (string)   
//   Name of the docker-machine, required if using docker-machine.
// * `content` (string)   
//   The content of the docker-compose.yml to write if not exist.
// * `eof` (string)   
//   Inherited from nikita.file use when writing docker-compose.yml file.
// * `backup` (string|boolean)   
//   Create a backup, append a provided string to the filename extension or a
//   timestamp if value is not a string, only apply if the target file exists and
//   is modified.
// * `detached` (boolean)   
//   Run Containers in detached mode. Default to true.
// * `force` (boolean)   
//   Force to re-create the containers if the config and image have not changed
//   Default to false
// * `services` (string|array)
//   Specify specific services to create.
// * `target` (string)   
//   The docker-compose.yml absolute's file's path, required if no content is 
//   specified.
// * `code` (int|array)   
//   Expected code(s) returned by the command, int or array of int, default to 0.
// * `code_skipped`   
//   Expected code(s) returned by the command if it has no effect, executed will
//   not be incremented, int or array of int.

// ## Callback parameters

// *   `err`   
//     Error object if any.   
// *   `executed`   
//     if command was executed   
// *   `stdout`   
//     Stdout value(s) unless `stdout` option is provided.   
// *   `stderr`   
//     Stderr value(s) unless `stderr` option is provided.   

// ## Source Code
var docker, path;

module.exports = function(options) {
  var clean_target, cmd, cmd_ps, cmd_up, k, ref, services, source_dir, v;
  this.log({
    message: "Entering Docker Compose",
    level: 'DEBUG',
    module: 'nikita/lib/docker/compose/up'
  });
  // Global options
  if (options.docker == null) {
    options.docker = {};
  }
  ref = options.docker;
  for (k in ref) {
    v = ref[k];
    if (options[k] == null) {
      options[k] = v;
    }
  }
  if ((options.target == null) && (options.content == null)) {
    // Validate parameters
    throw Error('Missing docker-compose content or target');
  }
  if (options.content && (options.target == null)) {
    if (options.target == null) {
      options.target = `/tmp/nikita_docker_compose_${Date.now()}/docker-compose.yml`;
    }
    clean_target = true;
  }
  if (options.detached == null) {
    options.detached = true;
  }
  if (options.force == null) {
    options.force = false;
  }
  if (options.recreate == null) {
    options.recreate = false;
  }
  if (options.services == null) {
    options.services = [];
  }
  if (!Array.isArray(options.services)) {
    options.services = [options.services];
  }
  services = options.services.join(' ');
  // Construct exec command
  cmd = ` --file ${options.target}`;
  cmd_ps = `${cmd} ps -q | xargs docker ${docker.opts(options)} inspect`;
  cmd_up = `${cmd} up`;
  if (options.detached) {
    cmd_up += ' -d ';
  }
  if (options.force) {
    cmd_up += ' --force-recreate ';
  }
  cmd_up += ` ${services}`;
  source_dir = `${path.dirname(options.target)}`;
  if (options.eof == null) {
    options.eof = true;
  }
  if (options.backup == null) {
    options.backup = false;
  }
  options.compose = true;
  this.call(function() {
    return this.file.yaml({
      if: options.content != null,
      eof: options.eof,
      backup: options.backup,
      target: options.target,
      content: options.content
    });
  });
  this.call(function(_, callback) {
    return this.system.execute({
      cmd: docker.wrap(options, cmd_ps),
      cwd: options.cwd,
      uid: options.uid,
      code_skipped: 123,
      stdout_log: false
    }, function(err, {status, stdout}) {
      var containers;
      if (err) {
        return callback(err);
      }
      if (!status) {
        return callback(null, true);
      }
      containers = JSON.parse(stdout);
      status = containers.some(function(container) {
        return !container.State.Running;
      });
      if (status) {
        this.log("Docker created, need start");
      }
      return callback(null, status);
    });
  });
  this.system.execute({
    if: function() {
      return options.force || this.status();
    },
    cwd: source_dir,
    uid: options.uid,
    cmd: docker.wrap(options, cmd_up)
  }, docker.callback);
  return this.system.remove({
    if: clean_target,
    target: options.target,
    always: true // Not yet implemented
  });
};


// ## Modules Dependencies
docker = require('../../misc/docker');

path = require('path');
