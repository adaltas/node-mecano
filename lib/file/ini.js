// Generated by CoffeeScript 2.3.1
// # `nikita.file.ini(options, callback)`

// Write an object as .ini file. Note, we are internally using the [ini] module.
// However, there is a subtile difference. Any key provided with value of 
// `undefined` or `null` will be disregarded. Within a `merge`, it get more
// prowerfull and tricky: the original value will be kept if `undefined` is
// provided while the value will be removed if `null` is provided.

// The `file.ini` function rely on the `file` function and accept all of its
// options. It introduces the `merge` option which instruct to read the
// target file if it exists and merge its parsed object with the one
// provided in the `content` option.

// ## Options   

// * `backup` (string|boolean)   
//   Create a backup, append a provided string to the filename extension or a
//   timestamp if value is not a string, only apply if the target file exists and
//   is modified.
// * `clean`   
//   Remove all the lines whithout a key and a value, default to "true".
// * `content` (object)   
//   Object to stringify.
// * `escape` (boolean)   
//   Escape the section's header title replace '.' by '\.'; "true" by default.
// * `merge`   
//   Read the target if it exists and merge its content.
// * `parse`   
//   User-defined function to parse the content from ini format, default to
//   `require('ini').parse`, see 'misc.ini.parse_multi_brackets'.
// * `separator`   
//   Default separator between keys and values, default to " : ".
// * `stringify`   
//   User-defined function to stringify the content to ini format, default to
//   `require('ini').stringify`, see 'misc.ini.stringify_square_then_curly' for
//   an example.
// * `eol` (string)   
//   Characters for line delimiter, usage depends on the stringify option, with 
//   the default stringify option, default to unix style if executed remotely 
//   (SSH) or to the platform if executed locally ("\r\n for windows", 
//   "\n" otherwise)
// * `source` (string)   
//   Path to a ini file providing default options; lower precedence than the
//   content object; may be used conjointly with the local option; optional, use
//   should_exists to enforce its presence.
// * `target`   
//   File path where to write content to or a callback.

// ## Callback parameters

// * `err`   
//   Error object if any.   
// * `written`   
//   Number of written actions with modifications.   

// ## Example

// ```js
// require('nikita').ini({
//   content: {
//     'my_key': 'my value'
//   },
//   target: '/tmp/my_file'
// }, function(err, written){
//   console.log(err ? err.message : 'Content was updated: ' + !!written);
// });
// ```

// ## Source Code
var merge, misc;

module.exports = function(options) {
  var default_props, org_props, parse;
  this.log({
    message: "Entering file.ini",
    level: 'DEBUG',
    module: 'nikita/lib/file/ini'
  });
  // Normalization
  if (options.clean == null) {
    options.clean = true;
  }
  if (options.escape == null) {
    options.escape = true;
  }
  if (options.content == null) {
    options.content = {};
  }
  if (options.encoding == null) {
    options.encoding = 'utf8';
  }
  if (!(options.content || !options.source)) {
    // Validation
    throw Error("Required Option: one of 'content' or 'source' is mandatory");
  }
  if (!options.target) {
    throw Error("Required Option: option 'target' is mandatory");
  }
  org_props = {};
  default_props = {};
  parse = options.parse || misc.ini.parse;
  // Original properties
  this.fs.readFile({
    ssh: options.ssh,
    target: options.target,
    encoding: options.encoding,
    relax: true
  }, function(err, {data}) {
    if ((err != null ? err.code : void 0) === 'ENOENT') {
      return;
    }
    if (err) {
      throw err;
    }
    return org_props = misc.merge(parse(data, options));
  });
  // Default properties
  this.fs.readFile({
    if: options.source,
    ssh: options.local ? false : options.ssh,
    target: options.source,
    encoding: options.encoding,
    relax: true
  }, function(err, {data}) {
    var content;
    if ((err != null ? err.code : void 0) === 'ENOENT') {
      return;
    }
    if (err) {
      throw err;
    }
    if (!options.source) {
      return;
    }
    content = misc.ini.clean(options.content, true);
    return options.content = misc.merge(parse(data, options), options.content);
  });
  // Merge
  this.call({
    if: options.merge
  }, function(_, callback) {
    options.content = misc.merge(org_props, options.content);
    this.log({
      message: "Get content for merge",
      level: 'DEBUG',
      module: 'nikita/lib/file/ini'
    });
    return callback();
  });
  return this.call(function() {
    var stringify;
    if (options.clean) {
      this.log({
        message: "Clean content",
        level: 'INFO',
        module: 'nikita/lib/file/ini'
      });
      misc.ini.clean(options.content);
    }
    this.log({
      message: "Serialize content",
      level: 'DEBUG',
      module: 'nikita/lib/file/ini'
    });
    stringify = options.stringify || misc.ini.stringify;
    return this.file({
      target: options.target,
      content: stringify(options.content, options),
      backup: options.backup,
      diff: options.diff,
      eof: options.eof,
      gid: options.gid,
      uid: options.uid,
      mode: options.mode
    });
  });
};

// ## Dependencies
misc = require('../misc');

({merge} = require('../misc'));

// [ini]: https://github.com/isaacs/ini
