// Generated by CoffeeScript 2.3.1
  // # `nikita.file.assert(options)`

  // Assert a file exists or a provided text match the content of a text file.

  // ## Options

  // * `content` (buffer|string)   
  //   Text to validate.   
  // * `encoding` (string)   
  //   Content encoding, see the Node.js supported Buffer encoding.   
  // * `filetype` (string|array)   
  //   Validate the file, could be any [file type constants](https://nodejs.org/api/fs.html#fs_file_type_constants)
  //   or one of 'ifreg', 'file', 'ifdir', 'directory', 'ifchr', 'chardevice', 
  //   'iffblk', 'blockdevice', 'ififo', 'fifo', 'iflink', 'symlink', 'ifsock', 
  //   'socket'.   
  // * `md5` (string)   
  //   Validate signature.   
  // * `mode` (string)   
  //   Validate file permissions.   
  // * `not` (boolean)   
  //   Negates the validation.   
  // * `sha1` (string)   
  //   Validate signature.    
  // * `sha256` (string)   
  //   Validate signature.   
  // * `source` (string)   
  //   Alias of option "target".   
  // * `target` (string)   
  //   File storing the content to assert.   
  // * `trim` (boolean)   
  //   Trim the actuel and expected content before matching, default is "false".
  // * `uid` (int|string)   
  //   User ID to assert.   
  // * `gid` (int|string)   
  //   Group ID to assert.   

  // ## Callback parameters

  // * `err` (Error)   
  //   Error if assertion failed.   

  // ## Examples

  // Validate the content of a file:

  // ```js
  // nikita.file.assert({
  //   ssh: connection
  //   target: '/tmp/a_file'     
  //   content: 'nikita is around' 
  // }, function(err){
  //   console.info(err);
  // });
  // ```

  // Ensure a file does not exists:

  // ```js
  // nikita.file.assert({
  //   ssh: connection
  //   target: '/tmp/a_file'     
  //   not: true
  // }, function(err){
  //   console.info(err);
  // });
  // ```

  // ## Source code
var buffer, file, fs, misc, pad,
  indexOf = [].indexOf;

module.exports = function(options) {
  var algo, filetype, hash, ssh;
  this.log({
    message: "Entering file.assert",
    level: 'DEBUG',
    module: 'nikita/lib/file/assert'
  });
  // SSH connection
  ssh = this.ssh(options.ssh);
  // Options
  if (options.trim == null) {
    options.trim = false;
  }
  if (options.encoding == null) {
    options.encoding = 'utf8';
  }
  if (options.target == null) {
    options.target = options.argument;
  }
  if (options.target == null) {
    options.target = options.source;
  }
  if (options.filetype == null) {
    options.filetype = [];
  }
  if (!Array.isArray(options.filetype)) {
    options.filetype = [options.filetype];
  }
  options.filetype = (function() {
    var i, len, ref, results;
    ref = options.filetype;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      filetype = ref[i];
      if (!filetype) {
        continue;
      }
      if (typeof filetype === 'string') {
        switch (filetype.toLowerCase()) {
          case 'ifreg':
          case 'file':
            results.push(fs.constants.S_IFREG);
            break;
          case 'ifdir':
          case 'directory':
            results.push(fs.constants.S_IFDIR);
            break;
          case 'ifchr':
          case 'chardevice':
            results.push(fs.constants.S_IFCHR);
            break;
          case 'iffblk':
          case 'blockdevice':
            results.push(fs.constants.S_IFBLK);
            break;
          case 'ififo':
          case 'fifo':
            results.push(fs.constants.S_IFIFO);
            break;
          case 'iflink':
          case 'symlink':
            results.push(fs.constants.S_IFLNK);
            break;
          case 'ifsock':
          case 'socket':
            results.push(fs.constants.S_IFSOCK);
            break;
          default:
            results.push(filetype);
        }
      } else {
        results.push(filetype);
      }
    }
    return results;
  })();
  if (options.mode == null) {
    options.mode = [];
  }
  if (!Array.isArray(options.mode)) {
    options.mode = [options.mode];
  }
  if (!options.target) {
    throw Error('Missing option: "target"');
  }
  if (typeof options.content === 'string') {
    if (options.trim) {
      options.content = options.content.trim();
    }
    options.content = Buffer.from(options.content, options.encoding);
  } else if (Buffer.isBuffer(options.content)) {
    if (options.trim) {
      options.content = buffer.trim(options.content, options.encoding);
    }
  } else if ((options.content != null) && !options.content instanceof RegExp) {
    throw Error("Invalid option 'content': expect string, buffer or regexp");
  }
  // Assert file exists
  this.call({
    unless: (options.content != null) || options.md5 || options.sha1 || options.sha256 || options.mode.length
  }, function(_, callback) {
    return this.fs.exists({
      ssh: options.ssh,
      target: options.target.toString()
    }, function(err, {exists}) {
      if (!options.not) {
        if (!exists) {
          if (options.error == null) {
            options.error = `File does not exists: ${JSON.stringify(options.target)}`;
          }
          err = Error(options.error);
        }
      } else {
        if (exists) {
          if (options.error == null) {
            options.error = `File exists: ${JSON.stringify(options.target)}`;
          }
          err = Error(options.error);
        }
      }
      return callback(err);
    });
  });
  // Assert file filetype
  this.call({
    if: options.filetype.length
  }, function(_, callback) {
    return this.fs.lstat({
      ssh: options.ssh,
      target: options.target
    }, function(err, {stats}) {
      var ref, ref1, ref2, ref3, ref4, ref5, ref6;
      if (err) {
        return callback(err);
      }
      if (ref = fs.constants.S_IFREG, indexOf.call(options.filetype, ref) >= 0) {
        if (!misc.stats.isFile(stats.mode)) {
          return callback(Error("Invalid filetype: expect a regular file"));
        }
      } else if (ref1 = fs.constants.S_IFDIR, indexOf.call(options.filetype, ref1) >= 0) {
        if (!misc.stats.isDirectory(stats.mode)) {
          return callback(Error("Invalid filetype: expect a directory"));
        }
      } else if (ref2 = fs.constants.S_IFCHR, indexOf.call(options.filetype, ref2) >= 0) {
        if (!misc.stats.isCharacterDevice(stats.mode)) {
          return callback(Error("Invalid filetype: expect a character-oriented device file"));
        }
      } else if (ref3 = fs.constants.S_IFBLK, indexOf.call(options.filetype, ref3) >= 0) {
        if (!misc.stats.isBlockDevice(stats.mode)) {
          return callback(Error("Invalid filetype: expect a block-oriented device file"));
        }
      } else if (ref4 = fs.constants.S_IFIFO, indexOf.call(options.filetype, ref4) >= 0) {
        if (!misc.stats.isFIFO(stats.mode)) {
          return callback(Error("Invalid filetype: expect a FIFO/pipe"));
        }
      } else if (ref5 = fs.constants.S_IFLNK, indexOf.call(options.filetype, ref5) >= 0) {
        if (!misc.stats.isSymbolicLink(stats.mode)) {
          return callback(Error("Invalid filetype: expect a symbolic link"));
        }
      } else if (ref6 = fs.constants.S_IFSOCK, indexOf.call(options.filetype, ref6) >= 0) {
        if (!misc.stats.isSocket(stats.mode)) {
          return callback(Error("Invalid filetype: expect a socket"));
        }
      } else {
        return callback(Error(`Invalid filetype: ${options.filetype.join(' ')}`));
      }
      return callback();
    });
  });
  // Assert content equal
  this.call({
    if: (options.content != null) && (typeof options.content === 'string' || Buffer.isBuffer(options.content))
  }, function(_, callback) {
    return this.fs.readFile({
      ssh: options.ssh,
      target: options.target
    }, function(err, {data}) {
      if (err) {
        return callback(err);
      }
      if (options.trim) {
        data = buffer.trim(data, options.encoding);
      }
      if (!options.not) {
        if (!data.equals(options.content)) {
          if (options.error == null) {
            options.error = `Invalid content: expect ${JSON.stringify(options.content.toString())} and got ${JSON.stringify(data.toString())}`;
          }
          err = Error(options.error);
        }
      } else {
        if (data.equals(options.content)) {
          if (options.error == null) {
            options.error = `Unexpected content: ${JSON.stringify(options.content.toString())}`;
          }
          err = Error(options.error);
        }
      }
      return callback(err);
    });
  });
  // Assert content match
  this.call({
    if: (options.content != null) && options.content instanceof RegExp
  }, function(_, callback) {
    return this.fs.readFile({
      ssh: options.ssh,
      target: options.target
    }, function(err, {data}) {
      if (err) {
        return callback(err);
      }
      if (!options.not) {
        if (!options.content.test(data)) {
          if (options.error == null) {
            options.error = `Invalid content match: expect ${JSON.stringify(options.content.toString())} and got ${JSON.stringify(buffer.toString())}`;
          }
          err = Error(options.error);
        }
      } else {
        if (options.content.test(data)) {
          if (options.error == null) {
            options.error = `Unexpected content match: ${JSON.stringify(options.content.toString())}`;
          }
          err = Error(options.error);
        }
      }
      return callback(err);
    });
  });
  if (options.md5) {
    // Assert hash match
    (algo = 'md5', hash = options.md5);
  }
  if (options.sha1) {
    (algo = 'sha1', hash = options.sha1);
  }
  if (options.sha256) {
    (algo = 'sha256', hash = options.sha256);
  }
  this.call({
    if: algo
  }, function(_, callback) {
    return file.hash(ssh, options.target, algo, (err, h) => {
      if ((err != null ? err.code : void 0) === 'ENOENT') {
        return callback(Error(`Target does not exists: ${options.target}`));
      }
      if (err) {
        return callback(err);
      }
      if (!options.not) {
        if (hash !== h) {
          if (options.error == null) {
            options.error = `Invalid ${algo} signature: expect ${JSON.stringify(hash)} and got ${JSON.stringify(h)}`;
          }
          err = Error(options.error);
        }
      } else {
        if (hash === h) {
          if (options.error == null) {
            options.error = `Matching ${algo} signature: ${JSON.stringify(hash)}`;
          }
          err = Error(options.error);
        }
      }
      return callback(err);
    });
  });
  // Assert uid ownerships
  this.call({
    if: options.uid != null
  }, function(_, callback) {
    return this.fs.stat({
      ssh: options.ssh,
      target: options.target
    }, function(err, {stats}) {
      if ((err != null ? err.code : void 0) === 'ENOENT') {
        return callback(Error(`Target does not exists: ${options.target}`));
      }
      if (!options.not) {
        if (`${stats.uid}` !== `${options.uid}`) {
          if (options.error == null) {
            options.error = `Unexpected uid: expected "${options.uid}" and got "${stats.uid}"`;
          }
          err = Error(options.error);
        }
      } else {
        if (`${stats.uid}` === `${options.uid}`) {
          if (options.error == null) {
            options.error = `Unexpected matching uid: expected "${options.uid}"`;
          }
          err = Error(options.error);
        }
      }
      return callback(err);
    });
  });
  // Assert gid ownerships
  this.call({
    if: options.gid != null
  }, function(_, callback) {
    return this.fs.stat({
      ssh: options.ssh,
      target: options.target
    }, function(err, {stats}) {
      if ((err != null ? err.code : void 0) === 'ENOENT') {
        return callback(Error(`Target does not exists: ${options.target}`));
      }
      if (!options.not) {
        if (`${stats.gid}` !== `${options.gid}`) {
          if (options.error == null) {
            options.error = `Unexpected gid: expected "${options.gid}" and got "${stats.gid}"`;
          }
          err = Error(options.error);
        }
      } else {
        if (`${stats.gid}` === `${options.gid}`) {
          if (options.error == null) {
            options.error = `Unexpected matching gid: expected "${options.gid}"`;
          }
          err = Error(options.error);
        }
      }
      return callback(err);
    });
  });
  // Assert file permissions
  return this.call({
    if: options.mode.length
  }, function(_, callback) {
    return this.fs.stat({
      ssh: options.ssh,
      target: options.target
    }, function(err, {stats}) {
      var expect;
      if ((err != null ? err.code : void 0) === 'ENOENT') {
        return callback(Error(`Target does not exists: ${options.target}`));
      }
      if (!options.not) {
        if (!misc.mode.compare(options.mode, stats.mode)) {
          expect = options.mode.map(function(mode) {
            return `${pad(4, misc.mode.stringify(mode), '0')}`;
          });
          if (options.error == null) {
            options.error = `Invalid mode: expect ${expect} and got ${misc.mode.stringify(stats.mode).substr(-4)}`;
          }
          err = Error(options.error);
        }
      } else {
        if (misc.mode.compare(options.mode, stats.mode)) {
          expect = options.mode.map(function(mode) {
            return `${pad(4, misc.mode.stringify(mode), '0')}`;
          });
          if (options.error == null) {
            options.error = `Unexpected valid mode: ${expect}`;
          }
          err = Error(options.error);
        }
      }
      return callback(err);
    });
  });
};

// ## Dependencies
pad = require('pad');

fs = require('fs');

misc = require('../misc');

file = require('../misc/file');

buffer = require('../misc/buffer');
