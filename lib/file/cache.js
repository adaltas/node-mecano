// Generated by CoffeeScript 2.3.1
  // # `nikita.file.cache(options, [callback])`

  // Download a file and place it on a local or remote folder for later usage.

  // ## Options

  // * `cache_dir` (path)    
  //   If local_cache is not a string, the cache file path is resolved from cache dir and cache file.
  //   By default: './'    
  // * `cache_file` (string | boolean)   
  //   Alias for "target".   
  // * `cache_local` (boolean)   
  //   Apply to SSH mode, treat the cache file and directories as local from where
  //   the command is used instead of over SSH.   
  // * `fail` (boolean)   
  //   Send an error if the HTTP response code is invalid. Similar to the curl
  //   option of the same name.   
  // * `force` (boolean)   
  //   Overwrite the target file if it exists, bypass md5 verification.   
  // * `headers` (array)   
  //   Extra header  to include in the request when sending HTTP to a server.   
  // * `location` (boolean)   
  //   If the server reports that the requested page has moved to a different
  //   location (indicated with a Location: header and a 3XX response code), this
  //   option will make curl redo the request on the new place.   
  // * `proxy` (string)   
  //   Use the specified HTTP proxy. If the port number is not specified, it is
  //   assumed at port 1080. See curl(1) man page.   
  // * `source` (path)   
  //   File, HTTP URL, FTP, GIT repository. File is the default protocol if source
  //   is provided without any.   
  // * `target` (string | boolean)   
  //   Cache the file on the executing machine, equivalent to cache unless an ssh
  //   connection is provided. If a string is provided, it will be the cache path.
  //   Default to the basename of source.   

  // ## Callback Parameters

  // * `err`   
  //   Error object if any.   
  // * `status`   
  //   Value is "true" if cache file was created or modified.   

  // ## HTTP example

  // ```js
  // require('nikita').download({
  //   source: 'https://github.com/wdavidw/node-nikita/tarball/v0.0.1',
  //   cache_dir: '/var/tmp'
  // }, function(err, status){
  //   console.info(err ? err.message : 'File downloaded: ' + status);
  // });
  // ```

  // ## Source Code
var curl, file, path, protocols_ftp, protocols_http, url,
  indexOf = [].indexOf;

module.exports = function(options, callback) {
  var algo, cmd, fail, hash, header, i, k, len, ref, ref1, ref2, ref3, ref4, ssh, u;
  this.log({
    message: "Entering file.cache",
    level: 'DEBUG',
    module: 'nikita/lib/file/cache'
  });
  // SSH connection
  ssh = this.ssh(options.ssh);
  if (options.argument != null) {
    // Options
    options.source = options.argument;
  }
  if (!options.source) {
    throw Error(`Missing source: '${options.source}'`);
  }
  if (!(options.cache_file || options.target || options.cache_dir)) {
    throw Error("Missing one of 'target', 'cache_file' or 'cache_dir' option");
  }
  if (options.target == null) {
    options.target = options.cache_file;
  }
  if (options.target == null) {
    options.target = path.basename(options.source);
  }
  options.target = path.resolve(options.cache_dir, options.target);
  if (/^file:\/\//.test(options.source)) {
    options.source = options.source.substr(7);
  }
  if (options.headers == null) {
    options.headers = [];
  }
  if (options.md5 != null) {
    if ((ref = typeof options.md5) !== 'string' && ref !== 'boolean') {
      throw Error(`Invalid MD5 Hash:${options.md5}`);
    }
    algo = 'md5';
    hash = options.md5;
  } else if (options.sha1 != null) {
    if ((ref1 = typeof options.sha1) !== 'string' && ref1 !== 'boolean') {
      throw Error(`Invalid SHA-1 Hash:${options.sha1}`);
    }
    algo = 'sha1';
    hash = options.sha1;
  } else if (options.sha256 != null) {
    if ((ref2 = typeof options.sha256) !== 'string' && ref2 !== 'boolean') {
      throw Error(`Invalid SHA-1 Hash:${options.sha256}`);
    }
    algo = 'sha256';
    hash = options.sha256;
  } else {
    algo = 'md5';
    hash = false;
  }
  u = url.parse(options.source);
  this.call(function(_, callback) {
    if (u.protocol !== null) {
      this.log({
        message: "Bypass source hash computation for non-file protocols",
        level: 'WARN',
        module: 'nikita/lib/file/cache'
      });
      return callback();
    }
    if (hash !== true) {
      return callback();
    }
    return file.hash(ssh, options.source, algo, (err, value) => {
      if (err) {
        return callback(err);
      }
      this.log({
        message: `Computed hash value is '${value}'`,
        level: 'INFO',
        module: 'nikita/lib/file/cache'
      });
      hash = value;
      return callback();
    });
  });
  // Download the file if
  // - file doesnt exist
  // - option force is provided
  // - hash isnt true and doesnt match
  this.call({
    shy: true
  }, function(_, callback) {
    this.log({
      message: `Check if target (${options.target}) exists`,
      level: 'DEBUG',
      module: 'nikita/lib/file/cache'
    });
    return this.fs.exists({
      ssh: options.ssh,
      target: options.target
    }, (err, {exists}) => {
      if (err) {
        return callback(err);
      }
      if (exists) {
        this.log({
          message: "Target file exists",
          level: 'INFO',
          module: 'nikita/lib/file/cache'
        });
        // If no checksum , we ignore MD5 check
        if (options.force) {
          this.log({
            message: "Force mode, cache will be overwritten",
            level: 'DEBUG',
            module: 'nikita/lib/file/cache'
          });
          return callback(null, true);
        } else if (hash && typeof hash === 'string') {
          // then we compute the checksum of the file
          this.log({
            message: `Comparing ${algo} hash`,
            level: 'DEBUG',
            module: 'nikita/lib/file/cache'
          });
          return file.hash(ssh, options.target, algo, (err, c_hash) => {
            if (err) {
              return callback(err);
            }
            // And compare with the checksum provided by the user
            if (hash === c_hash) {
              this.log({
                message: "Hashes match, skipping",
                level: 'DEBUG',
                module: 'nikita/lib/file/cache'
              });
              return callback(null, false);
            }
            this.log({
              message: "Hashes don't match, delete then re-download",
              level: 'WARN',
              module: 'nikita/lib/file/cache'
            });
            return this.fs.unlink({
              ssh: options.ssh,
              target: options.target
            }, function(err) {
              if (err) {
                return callback(err);
              }
              return callback(null, true);
            });
          });
        } else {
          this.log({
            message: "Target file exists, check disabled, skipping",
            level: 'DEBUG',
            module: 'nikita/lib/file/cache'
          });
          return callback(null, false);
        }
      } else {
        this.log({
          message: "Target file does not exists",
          level: 'INFO',
          module: 'nikita/lib/file/cache'
        });
        return callback(null, true);
      }
    });
  }, function(err, status) {
    if (!status) {
      return this.end();
    }
  });
  // Place into cache
  if (ref3 = u.protocol, indexOf.call(protocols_http, ref3) >= 0) {
    fail = options.fail ? "--fail" : '';
    k = u.protocol === 'https:' ? '-k' : '';
    cmd = `curl ${fail} ${k} -s ${options.source} -o ${options.target}`;
    if (options.location) {
      cmd += " --location";
    }
    ref4 = options.headers;
    for (i = 0, len = ref4.length; i < len; i++) {
      header = ref4[i];
      cmd += ` --header "${header}"`;
    }
    if (options.proxy) {
      cmd += ` -x ${options.proxy}`;
    }
    this.system.mkdir({
      ssh: options.cache_local ? false : ssh,
      target: path.dirname(options.target)
    });
    this.system.execute({
      cmd: cmd,
      ssh: options.cache_local ? false : ssh,
      unless_exists: options.target
    });
  } else {
    this.system.mkdir({ // todo: copy shall handle this
      target: `${path.dirname(options.target)}`
    });
    this.system.copy({
      source: `${options.source}`,
      target: `${options.target}`
    });
  }
  // TODO: validate the cache
  return this.next(function(err, {status}) {
    return callback(err, {
      status: status,
      target: options.target
    });
  });
};

module.exports.protocols_http = protocols_http = ['http:', 'https:'];

module.exports.protocols_ftp = protocols_ftp = ['ftp:', 'ftps:'];

// ## Dependencies
path = require('path');

url = require('url');

curl = require('../misc/curl');

file = require('../misc/file');
