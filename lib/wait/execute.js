// Generated by CoffeeScript 2.3.1
// # `nikita.wait.execute(options, [callback])`

// Run a command periodically and continue once the command succeed. Status will be
// set to "false" if the user command succeed right away, considering that no
// change had occured. Otherwise it will be set to "true".   

// ## Options  

// * `quorum` (number|boolean)    
//   Number of minimal successful connection, 50%+1 if "true".   
// * `cmd` (string|array)   
//   The commands to be executed.    
// * `interval`   
//   Time interval between which we should wait before re-executing the command,
//   default to 2s.   
// * `code`   
//   Expected exit code to recieve to exit and call the user callback, default to "0".   
// * `code_skipped`   
//   Expected code to be returned when the command failed and should be scheduled
//   for later execution, default to "1".   
// * `stdin_log` (boolean)   
//   Pass stdin output to the logs of type "stdin_stream", default is "true".
// * `stdout_log` (boolean)   
//   Pass stdout output to the logs of type "stdout_stream", default is "true".
// * `stderr_log` (boolean)   
//   Pass stderr output to the logs of type "stderr_stream", default is "true".

// ## Example

// ```js
// require('nikita')
// .wait.execute({
//   cmd: "test -f /tmp/sth"
// }, function(err, status){
//   // Command succeed, the file "/tmp/sth" now exists
// })
// ```

// ## Source Code
var each;

module.exports = function(options, callback) {
  var modified, quorum_current;
  this.log({
    message: "Entering wait for execution",
    level: 'DEBUG',
    module: 'nikita/lib/wait/execute'
  });
  if (typeof (options.argument != null)) {
    // Validate parameters
    if (options.cmd == null) {
      options.cmd = options.argument;
    }
  }
  if (options.cmd == null) {
    return callback(Error(`Missing cmd: ${options.cmd}`));
  }
  if (!Array.isArray(options.cmd)) {
    options.cmd = [options.cmd];
  }
  options.quorum = options.quorum;
  if (options.quorum && options.quorum === true) {
    options.quorum = Math.ceil(options.cmd.length / 2);
  } else if (options.quorum == null) {
    options.quorum = options.cmd.length;
  }
  if (options.interval == null) {
    options.interval = 2000;
  }
  if (options.code_skipped == null) {
    options.code_skipped = 1;
  }
  this.log({
    message: "Entering wait for execution",
    level: 'DEBUG',
    module: 'nikita/lib/wait/execute'
  });
  quorum_current = 0;
  modified = false;
  return each(options.cmd).call((cmd, next) => {
    var count, run;
    count = 0;
    if (quorum_current >= options.quorum) {
      return next();
    }
    run = () => {
      count++;
      this.log({
        message: `Attempt #${count}`,
        level: 'INFO',
        module: 'nikita/lib/wait/execute'
      });
      return this.system.execute({
        cmd: cmd,
        code: options.code || 0,
        code_skipped: options.code_skipped,
        stdin_log: options.stdin_log,
        stdout_log: options.stdout_log,
        stderr_log: options.stderr_log
      }, (err, {status}) => {
        if (!err && !status) {
          setTimeout(run, options.interval);
          return;
        }
        if (err) {
          return next(err);
        }
        this.log({
          message: "Finish wait for execution",
          level: 'INFO',
          module: 'nikita/lib/wait/execute'
        });
        quorum_current++;
        if (count > 1) {
          modified = true;
        }
        return next();
      });
    };
    return run();
  }).next(function(err) {
    return callback(err, modified);
  });
};

// ## Dependencies
each = require('each');
