// Generated by CoffeeScript 2.3.1
// # `nikita.system.copy(options, [callback])`

// Copy a file. The behavior is similar to the one of the `cp`
// Unix utility. Copying a file over an existing file will
// overwrite it.

// ## Options

// * `gid`   
//   Group name or id who owns the file.   
// * `mode`   
//   Permissions of the file or the parent directory.   
// * `parent` (boolean|object)   
//   Create parent directory with provided attributes if an object or default 
//   system options if "true", supported attributes include 'mode', 'uid', 'gid', 
//   'size', 'atime', and 'mtime'.   
// * `preserve`   
//   Preserve file ownerships and permissions, default to "false".
// * `source`   
//   The file or directory to copy.   
// * `source_stats`   
//   Short-circuit to prevent source stat retrieval if already at our disposal.   
// * `target`   
//   Where the file or directory is copied.   
// * `target_stats`   
//   Short-circuit to prevent target stat retrieval if already at our disposal.   
// * `uid`   
//   User name or id who owns the file.   

// ## Callback Parameters

// * `err`   
//   Error object if any.   
// * `status`   
//   Value is "true" if copied file was created or modified.   

// ## Todo

// * Apply permissions to directories
// * Handle symlinks
// * Handle globing
// * Preserve permissions if `mode` is `true`

// ## Example

// ```js
// require('nikita').system.copy({
//   source: '/etc/passwd',
//   target: '/etc/passwd.bck',
//   uid: 'my_user'
//   gid: 'my_group'
//   mode: '0755'
// }, function(err, status){
//   console.log(err ? err.message : 'File was copied: ' + status);
// });
// ```

// ## Source Code
var glob, misc, path;

module.exports = function(options) {
  var ssh;
  this.log({
    message: "Entering copy",
    level: 'DEBUG',
    module: 'nikita/lib/system/copy'
  });
  // SSH connection
  ssh = this.ssh(options.ssh);
  // Validate parameters.
  if (options.uid == null) {
    options.uid = null;
  }
  if (typeof options.uid === 'string' && !isNaN(parseInt(options.uid))) {
    options.uid = parseInt(options.uid);
  }
  if (options.gid == null) {
    options.gid = null;
  }
  if (typeof options.gid === 'string' && !isNaN(parseInt(options.uid))) {
    options.gid = parseInt(options.gid);
  }
  if (options.preserve == null) {
    options.preserve = false;
  }
  if (options.parent == null) {
    options.parent = {};
  }
  if (options.parent === true) {
    options.parent = {};
  }
  if (!options.source) {
    throw Error('Missing source');
  }
  if (!options.target) {
    throw Error('Missing target');
  }
  // Retrieve stats information about the source unless provided through the "source_stats" option.
  this.call(function(_, callback) {
    if (options.source_stats) {
      this.log({
        message: "Source Stats: using short circuit",
        level: 'DEBUG',
        module: 'nikita/lib/system/copy'
      });
      return callback();
    }
    this.log({
      message: `Stats source file ${options.source}`,
      level: 'DEBUG',
      module: 'nikita/lib/system/copy'
    });
    return this.fs.stat({
      ssh: options.ssh,
      target: options.source
    }, function(err, {stats}) {
      if (err) {
        return callback(err);
      }
      if (!err) {
        options.source_stats = stats;
      }
      return callback();
    });
  });
  // Retrieve stat information about the traget unless provided through the "target_stats" option.
  this.call(function(_, callback) {
    if (options.target_stats) {
      this.log({
        message: "Target Stats: using short circuit",
        level: 'DEBUG',
        module: 'nikita/lib/system/copy'
      });
      return callback();
    }
    this.log({
      message: `Stats target file ${options.target}`,
      level: 'DEBUG',
      module: 'nikita/lib/system/copy'
    });
    return this.fs.stat({
      ssh: options.ssh,
      target: options.target
    }, function(err, {stats}) {
      if (err && err.code !== 'ENOENT') {
        // Note, target file doesnt necessarily exist
        return callback(err);
      }
      if (stats) {
        options.target_stats = stats;
      }
      return callback();
    });
  });
  // Create target parent directory if target does not exists and if the "parent"
  // options is set to "true" (default) or as an object.
  this.system.mkdir({
    if: !!options.parent,
    unless: options.target_stats,
    target: path.dirname(options.target)
  }, options.parent);
  
  // Stop here if source is a directory. We traverse all its children
  // Recursively, calling either `system.mkdir` or `system.copy`.

  // Like with the Unix `cp` command, ending slash matters if the target directory 
  // exists. Let's consider a source directory "/tmp/a_source" and a target directory
  // "/tmp/a_target". Without an ending slash , the directory "/tmp/a_source" is 
  // copied into "/tmp/a_target/a_source". With an ending slash, all the files
  // present inside "/tmp/a_source" are copied inside "/tmp/a_target".
  this.call(function(_, callback) {
    var sourceEndWithSlash;
    if (!misc.stats.isDirectory(options.source_stats.mode)) {
      return callback();
    }
    sourceEndWithSlash = options.source.lastIndexOf('/') === options.source.length - 1;
    if (options.target_stats && !sourceEndWithSlash) {
      options.target = path.resolve(options.target, path.basename(options.source));
    }
    this.log({
      message: "Source is a directory",
      level: 'INFO',
      module: 'nikita/lib/system/copy'
    });
    this.call(function(_, callback) {
      return glob(ssh, `${options.source}/**`, {
        dot: true
      }, (err, sources) => {
        var i, len, source;
        if (err) {
          return callback(err);
        }
        for (i = 0, len = sources.length; i < len; i++) {
          source = sources[i];
          ((source) => {
            var target;
            target = path.resolve(options.target, path.relative(options.source, source));
            return this.call(function(_, callback) { // TODO: remove this line and indent up next line
              return this.fs.stat({
                ssh: options.ssh,
                target: source
              }, (err, {stats}) => {
                var gid, mode, uid;
                uid = options.uid;
                if (options.preserve) {
                  if (uid == null) {
                    uid = stats.uid;
                  }
                }
                gid = options.gid;
                if (options.preserve) {
                  if (gid == null) {
                    gid = stats.gid;
                  }
                }
                mode = options.mode;
                if (options.preserve) {
                  if (mode == null) {
                    mode = stats.mode;
                  }
                }
                if (misc.stats.isDirectory(stats.mode)) {
                  this.system.mkdir({
                    target: target,
                    uid: uid,
                    gid: gid,
                    mode: mode
                  });
                } else {
                  this.system.copy({
                    target: target,
                    source: source,
                    source_stat: stats,
                    uid: uid,
                    gid: gid,
                    mode: mode
                  });
                }
                return this.next(callback);
              });
            });
          })(source);
        }
        return this.next(callback);
      });
    });
    return this.next(function(err, {status}) {
      return callback(err, {
        status: status,
        end: true
      });
    });
  }, function(err, {end}) {
    if (!err && end) {
      return this.end();
    }
  });
  // If source is a file and target is a directory, then transform
  // target into a file.
  this.call(function() {
    if (!(options.target_stats && misc.stats.isDirectory(options.target_stats.mode))) {
      return;
    }
    return options.target = path.resolve(options.target, path.basename(options.source));
  });
  // Copy the file if content doesn't match.
  this.call(function(_, callback) {
    // Copy a file
    return misc.file.compare(ssh, [options.source, options.target], (err, md5) => {
      if (err && err.message.indexOf('Does not exist') !== 0) {
        // Destination may not exists
        return callback(err);
      }
      if (md5) {
        // Files are the same, we can skip copying
        return callback(null, false);
      }
      this.log({
        message: `Copy file from ${options.source} into ${options.target}`,
        level: 'WARN',
        module: 'nikita/lib/system/copy'
      });
      return this.fs.copy({
        ssh: options.ssh,
        source: options.source,
        target: options.target
      }, function(err) {
        return callback(err, true);
      });
    });
  }, function(err, status) {
    return this.log({
      message: `File ${options.source} copied`,
      level: 'DEBUG',
      module: 'nikita/lib/system/copy'
    });
  });
  // File ownership and permissions
  return this.call(function() {
    if (options.preserve) {
      if (options.uid == null) {
        options.uid = options.source_stats.uid;
      }
    }
    if (options.preserve) {
      if (options.gid == null) {
        options.gid = options.source_stats.gid;
      }
    }
    if (options.preserve) {
      if (options.mode == null) {
        options.mode = options.source_stats.mode;
      }
    }
    this.system.chown({
      target: options.target,
      stats: options.target_stats,
      uid: options.uid,
      gid: options.gid,
      if: (options.uid != null) || (options.gid != null)
    });
    return this.system.chmod({
      target: options.target,
      stats: options.target_stats,
      mode: options.mode,
      if: options.mode != null
    });
  });
};

// ## Dependencies
path = require('path');

misc = require('../misc');

glob = require('../misc/glob');
