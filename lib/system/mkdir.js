// Generated by CoffeeScript 2.3.1
// # `nikita.system.mkdir(options, [callback])`

// Recursively create a directory. The behavior is similar to the Unix command
// `mkdir -p`. It supports an alternative syntax where options is simply the path
// of the directory to create.

// ## Options

// * `cwd`   
//   Current working directory for relative paths.   
// * `uid`   
//   Unix user id.   
// * `gid`   
//   Unix group id.   
// * `mode`   
//   Default to "0755".   
// * `directory`   
//   Path or array of paths.   
// * `target`   
//   Alias for `directory`.   
// * `exclude`   
//   Regular expression.   
// * `parent` (boolean|object)   
//   Create parent directory with provided attributes if an object or default 
//   system options if "true", supported attributes include 'mode', 'uid', 'gid', 
//   'size', 'atime', and 'mtime'.   
// * `source`   
//   Alias for `directory`.   

// ## Callback Parameters

// * `err`   
//   Error object if any.   
// * `status`   
//   Value is "true" if directory was created or modified.   

// ## Simple usage

// ```js
// require('nikita')
// .system.mkdir('./some/dir', function(err, status){
//   console.info(err ? err.message : "Directory created: " + status);
// });
// ```

// ## Advanced usage

// ```js
// require('nikita')
// .system.mkdir({
//   ssh: ssh,
//   target: './some/dir',
//   uid: 'a_user',
//   gid: 'a_group'
//   mode: 0o0777 // or '777'
// }, function(err, status){
//   console.info(err ? err.message : 'Directory created: ' + status);
// });
// ```

// ## Source Code
var each, misc, path, wrap;

module.exports = function(options, callback) {
  var directory, i, j, len, p, ref, ssh, state;
  this.log({
    message: "Entering mkdir",
    level: 'DEBUG',
    module: 'nikita/lib/system/mkdir'
  });
  // SSH connection
  ssh = this.ssh(options.ssh);
  p = ssh ? path.posix : path;
  if (options.argument != null) {
    // Validate options
    options.target = options.argument;
  }
  if (options.directory == null) {
    options.directory = options.target;
  }
  if (options.directory == null) {
    options.directory = options.source;
  }
  if (options.directory == null) {
    return callback(Error('Missing target option'));
  }
  if (!ssh && (options.cwd === true || !options.cwd)) {
    options.cwd = process.cwd();
  }
  if (!Array.isArray(options.directory)) {
    options.directory = [options.directory];
  }
  if (options.parent === true) {
    options.parent = {};
  }
  ref = options.directory;
  for (i = j = 0, len = ref.length; j < len; i = ++j) {
    directory = ref[i];
    // Note: path.resolve also normalize
    options.directory[i] = directory = options.cwd ? p.resolve(options.cwd, directory) : p.normalize(directory);
    if (ssh) {
      if (!p.isAbsolute(directory)) {
        throw Error(`Non Absolute Path: target is ${JSON.stringify(directory)}, SSH requires absolute paths, you must provide an absolute path in the target or the cwd option`);
      }
    }
  }
  // State
  state = {
    status: false
  };
  return each(options.directory).call((directory, callback) => {
    var do_create, do_create_parent, do_stats, do_update;
    // first, we need to find which directory need to be created
    // @log message: "Creating directory '#{directory}'", level: 'DEBUG', module: 'nikita/lib/system/mkdir'
    do_stats = () => {
      var directories, dirs, end;
      end = false;
      dirs = [];
      // Create directory and its parent directories
      directories = directory.split('/');
      directories.shift(); // first element is empty with absolute path
      if (directories[directories.length - 1] === '') {
        directories.pop();
      }
      directories = (function() {
        var k, ref1, results;
        results = [];
        for (i = k = 0, ref1 = directories.length; (0 <= ref1 ? k < ref1 : k > ref1); i = 0 <= ref1 ? ++k : --k) {
          results.push('/' + directories.slice(0, directories.length - i).join('/'));
        }
        return results;
      })();
      return each(directories).call((directory, i, next) => {
        this.log({
          message: `Stat '${directory}'`,
          level: 'DEBUG',
          module: 'nikita/lib/system/mkdir'
        });
        return this.fs.stat({
          ssh: options.ssh,
          target: directory
        }, function(err, {stats}) {
          if ((err != null ? err.code : void 0) === 'ENOENT') { // if the directory is not yet created
            directory.stats = stats;
            dirs.push(directory);
            if (i === directories.length - 1) {
              return do_create_parent(dirs);
            } else {
              return next();
            }
          }
          if (misc.stats.isDirectory(stats.mode)) {
            end = true;
            if (i === 0) {
              return do_update(stats);
            } else {
              return do_create_parent(dirs);
            }
          }
          if (err) {
            return next(err); // a file or symlink exists at this location
          } else {
            return next(Error(`Not a directory: ${JSON.stringify(directory)}`));
          }
        });
      }).next(callback);
    };
    do_create_parent = (directories) => {
      return this.system.uid_gid({
        uid: options.uid,
        gid: options.gid
      }, function(err, {uid, gid}) {
        options.uid = uid;
        options.gid = gid;
        return do_create(directories);
      });
    };
    do_create = (directories) => {
      return each(directories.reverse()).call((directory, i, callback) => {
        var attr, k, len1, opts, ref1, ref2, val;
        // Directory name contains variables
        // eg /\${/ on './var/cache/${user}' creates './var/cache/'
        if ((options.exclude != null) && options.exclude instanceof RegExp) {
          if (options.exclude.test(path.basename(directory))) {
            return callback();
          }
        }
        this.log({
          message: `Create directory "${directory}"`,
          level: 'DEBUG',
          module: 'nikita/lib/system/mkdir' // unless directory is options.directory
        });
        opts = {};
        ref1 = ['mode', 'uid', 'gid', 'size', 'atime', 'mtime'];
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          attr = ref1[k];
          val = i === directories.length - 1 ? options[attr] : (ref2 = options.parent) != null ? ref2[attr] : void 0;
          if (val != null) {
            opts[attr] = val;
          }
        }
        return this.fs.mkdir({
          ssh: options.ssh,
          target: directory
        }, opts, function(err) {
          if (err) {
            return callback(err);
          }
          this.log({
            message: `Directory "${directory}" created `,
            level: 'INFO',
            module: 'nikita/lib/system/mkdir'
          });
          state.status = true;
          return callback();
        });
      }).next(function(err) {
        if (err) {
          return callback(err);
        }
        return callback();
      });
    };
    do_update = (stats) => {
      this.log({
        message: "Directory already exists",
        level: 'INFO',
        module: 'nikita/lib/system/mkdir'
      });
      this.system.chown({
        target: directory,
        stats: stats,
        uid: options.uid,
        gid: options.gid,
        if: (options.uid != null) || (options.gid != null)
      });
      this.system.chmod({
        target: directory,
        stats: stats,
        mode: options.mode,
        if: options.mode != null
      });
      return this.next(function(err, {status}) {
        if (err) {
          return callback(err);
        }
        if (status) {
          state.status = true;
        }
        return callback();
      });
    };
    return do_stats();
  }).next(function(err) {
    return callback(err, state.status);
  });
};

// ## Dependencies
path = require('path').posix;

each = require('each');

misc = require('../misc');

wrap = require('../misc/wrap');
