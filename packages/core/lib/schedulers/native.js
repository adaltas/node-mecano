// Generated by CoffeeScript 2.5.1
var is_object_literal, merge, utils;

utils = require('../utils');

({is_object_literal, merge} = require('mixme'));

module.exports = function(tasks, options = {}) {
  var clear_managed_tasks, has_pending_tasks, promise, scheduler, state;
  scheduler = null;
  // Managed tasks are resolved inside the scheduler promise. The promise
  // fullfil with an array which length is the number of managed tasks.
  // It is possible to defined `managed` globally for every handler and
  // individually for each handler when calling `push` or `unshift`.
  // By default, tasks passed in the scheduler creation are managed while
  // handler pushed or unshifted are not.
  // It is not possible to register managed handler once the scheduler has
  // resolved.
  if (options.managed == null) {
    options.managed = false;
  }
  if (options.parallel == null) {
    options.parallel = 1;
  }
  state = {
    stack: [],
    pause: options.pause != null ? !!options.pause : false,
    error: void 0,
    output: [],
    resolved: false,
    running: 0
  };
  has_pending_tasks = function() {
    var pending;
    pending = state.stack.some(function(task) {
      return task.managed;
    });
    return pending;
  };
  clear_managed_tasks = function() {
    return state.stack = state.stack.filter(function(task) {
      return !task.managed;
    });
  };
  promise = new Promise(function(resolve, reject) {
    scheduler = {
      state: state,
      pump: function() {
        var task;
        if (state.pause) {
          return;
        }
        if (state.running === options.parallel) {
          return;
        }
        if (!state.resolved) {
          if (state.error) {
            state.resolved = true;
            // Any pending managed task is stripped out after an error
            clear_managed_tasks();
            scheduler.pump();
            return reject(state.error);
          } else if (!has_pending_tasks()) {
            state.resolved = true;
            scheduler.pump();
            return resolve(state.output);
          }
        }
        if (!state.stack.length) {
          return;
        }
        state.running++;
        task = state.stack.shift();
        // A managed handler cannot be scheduled once the scheduler resolves
        if (task.managed && state.resolved) {
          throw utils.error('SCHEDULER_RESOLVED', ['cannot execute a new handler,', 'scheduler already in resolved state.']);
        }
        return setImmediate(async function() {
          var error, result;
          try {
            // console.log task
            result = (await task.handler.call());
            state.running--;
            task.resolve.call(null, result);
            if (task.managed) {
              state.output.push(result);
            }
            return setImmediate(scheduler.pump);
          } catch (error1) {
            error = error1;
            state.running--;
            task.reject.call(null, error);
            if (task.managed) {
              state.error = error;
            }
            return setImmediate(scheduler.pump);
          }
        });
      },
      unshift: function(tasks) {
        var isArray;
        isArray = Array.isArray(tasks);
        if (!isArray && typeof tasks === 'function') {
          tasks = {
            handler: tasks
          };
        }
        if (!(isArray || is_object_literal(tasks))) {
          throw Error('Invalid Argument');
        }
        return new Promise(function(resolve, reject) {
          var task;
          if (!isArray) {
            state.stack.unshift({
              ...options,
              ...tasks,
              resolve: resolve,
              reject: reject
            });
            return scheduler.pump();
          } else {
            // Unshift from the last to the first element to preserve order
            return Promise.all(((function() {
              var i, len, ref, results;
              ref = tasks.reverse();
              results = [];
              for (i = 0, len = ref.length; i < len; i++) {
                task = ref[i];
                results.push(scheduler.unshift(task));
              }
              return results;
            })()).reverse()).then(resolve, reject);
          }
        });
      },
      pause: function() {
        return state.pause = true;
      },
      resume: function() {
        if (!state.pause) {
          return;
        }
        state.pause = false;
        if (state.stack.length) {
          return scheduler.pump();
        }
      },
      push: function(tasks) {
        var isArray, prom;
        isArray = Array.isArray(tasks);
        if (!isArray && typeof tasks === 'function') {
          tasks = {
            handler: tasks
          };
        }
        if (!(isArray || is_object_literal(tasks))) {
          throw Error('Invalid Argument');
        }
        prom = new Promise(function(resolve, reject) {
          var task;
          if (!isArray) {
            // console.log {
            //   ...tasks
            //   ...options
            //   resolve: resolve
            //   reject: reject
            // }
            state.stack.push({
              ...options,
              ...tasks,
              resolve: resolve,
              reject: reject
            });
            return scheduler.pump();
          } else {
            return Promise.all((function() {
              var i, len, results;
              results = [];
              for (i = 0, len = tasks.length; i < len; i++) {
                task = tasks[i];
                results.push(scheduler.push(task));
              }
              return results;
            })()).then(resolve, reject);
          }
        });
        prom.catch((function() {})); // Handle strict unhandled rejections
        return prom;
      }
    };
    if (tasks) {
      if (tasks.length) {
        return scheduler.push(tasks.map(function(task) {
          if (typeof task === 'function') {
            task = {
              handler: task
            };
          }
          return {
            managed: true,
            ...task
          };
        }));
      } else {
        return resolve([]);
      }
    }
  });
  promise.catch((function() {})); // Handle strict unhandled rejections
  return new Proxy(promise, {
    get: function(target, name) {
      if (target[name] != null) {
        if (typeof target[name] === 'function') {
          return target[name].bind(target);
        } else {
          return target[name];
        }
      } else {
        return scheduler[name];
      }
    }
  });
};
