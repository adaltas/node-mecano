// Generated by CoffeeScript 2.5.1
var merge, utils;

utils = require('../utils');

({merge} = require('mixme'));

module.exports = function(handlers, options = {}) {
  var clear_managed_tasks, has_pending_tasks, promise, scheduler, state;
  scheduler = null;
  // Managed handlers are resolved inside the scheduler promise. The promise
  // fullfil with an array which length is the number of managed handlers.
  // It is possible to defined `managed` globally for every handler and
  // individually for each handler when calling `push` or `unshift`.
  // By default, handlers passed in the scheduler creation are managed while
  // handler pushed or unshifted are not.
  // It is not possible to register managed handler once the scheduler has
  // resolved.
  if (options.managed == null) {
    options.managed = false;
  }
  if (options.parallel == null) {
    options.parallel = 1;
  }
  state = {
    stack: [],
    pause: options.pause != null ? !!options.pause : false,
    error: void 0,
    output: [],
    resolved: false,
    running: 0
  };
  has_pending_tasks = function() {
    var pending;
    pending = state.stack.some(function(task) {
      return task.options.managed;
    });
    return pending;
  };
  clear_managed_tasks = function() {
    return state.stack = state.stack.filter(function(task) {
      return !task.options.managed;
    });
  };
  promise = new Promise(function(resolve, reject) {
    scheduler = {
      state: state,
      pump: function() {
        var item;
        if (state.pause) {
          return;
        }
        if (state.running === options.parallel) {
          return;
        }
        if (!state.resolved) {
          if (state.error) {
            state.resolved = true;
            // Any pending managed task is stripped out after an error
            clear_managed_tasks();
            scheduler.pump();
            return reject(state.error);
          } else if (!has_pending_tasks()) {
            state.resolved = true;
            scheduler.pump();
            return resolve(state.output);
          }
        }
        if (!state.stack.length) {
          return;
        }
        state.running++;
        item = state.stack.shift();
        // A managed handler cannot be scheduled once the scheduler resolves
        if (item.options.managed && state.resolved) {
          throw utils.error('SCHEDULER_RESOLVED', ['cannot execute a new handler,', 'scheduler already in resolved state.']);
        }
        return setImmediate(async function() {
          var error, result;
          try {
            result = (await item.handler.call());
            state.running--;
            item.resolve.call(null, result);
            if (item.options.managed) {
              state.output.push(result);
            }
            return setImmediate(scheduler.pump);
          } catch (error1) {
            error = error1;
            state.running--;
            item.reject.call(null, error);
            if (item.options.managed) {
              state.error = error;
            }
            return setImmediate(scheduler.pump);
          }
        });
      },
      unshift: function(handlers, opts = {}) {
        var isArray;
        isArray = Array.isArray(handlers);
        if (!(isArray || typeof handlers === 'function')) {
          throw Error('Invalid Argument');
        }
        return new Promise(function(resolve, reject) {
          var handler;
          if (!isArray) {
            state.stack.unshift({
              handler: handlers,
              resolve: resolve,
              reject: reject,
              options: merge(options, opts)
            });
            return scheduler.pump();
          } else {
            // Unshift from the last to the first element to preserve order
            return Promise.all(((function() {
              var i, len, ref, results;
              ref = handlers.reverse();
              results = [];
              for (i = 0, len = ref.length; i < len; i++) {
                handler = ref[i];
                results.push(scheduler.unshift(handler, opts));
              }
              return results;
            })()).reverse()).then(resolve, reject);
          }
        });
      },
      pause: function() {
        return state.pause = true;
      },
      resume: function() {
        if (!state.pause) {
          return;
        }
        state.pause = false;
        if (state.stack.length) {
          return scheduler.pump();
        }
      },
      push: function(handlers, opts = {}) {
        var isArray, prom;
        isArray = Array.isArray(handlers);
        if (!(isArray || typeof handlers === 'function')) {
          throw Error('Invalid Argument');
        }
        prom = new Promise(function(resolve, reject) {
          var handler;
          if (!isArray) {
            state.stack.push({
              handler: handlers,
              resolve: resolve,
              reject: reject,
              options: merge(options, opts)
            });
            return scheduler.pump();
          } else {
            return Promise.all((function() {
              var i, len, results;
              results = [];
              for (i = 0, len = handlers.length; i < len; i++) {
                handler = handlers[i];
                results.push(scheduler.push(handler, opts));
              }
              return results;
            })()).then(resolve, reject);
          }
        });
        prom.catch((function() {})); // Handle strict unhandled rejections
        return prom;
      }
    };
    if (handlers) {
      if (handlers.length) {
        return scheduler.push(handlers, {
          managed: true
        });
      } else {
        return resolve([]);
      }
    }
  });
  promise.catch((function() {})); // Handle strict unhandled rejections
  return new Proxy(promise, {
    get: function(target, name) {
      if (target[name] != null) {
        if (typeof target[name] === 'function') {
          return target[name].bind(target);
        } else {
          return target[name];
        }
      } else {
        return scheduler[name];
      }
    }
  });
};
