// Generated by CoffeeScript 2.5.1
// # `nikita.krb5.ktutil`

// Create and manage a keytab for an existing principal. It's different than ktadd
// in the way it can manage several principal on one keytab.

// ## Example

// ```
// require('nikita').krb5.ktutil.add({
//   principal: 'myservice/my.fqdn@MY.REALM',
//   keytab: '/etc/security/keytabs/my.service.keytab',
//   password: 'password'
// }, function(err, status){
//   console.info(err ? err.message : 'Keytab created or modified: ' + status);
// });
// ```

// ## Schema
var handler, mutate, schema, utils;

schema = {
  type: 'object',
  properties: {
    'admin': {
      $ref: 'module://@nikitajs/krb5/src/execute#/properties/admin'
    },
    'enctypes': {
      type: 'array',
      items: {
        type: 'string'
      },
      default: ['aes256-cts-hmac-sha1-96', 'aes128-cts-hmac-sha1-96', 'des3-cbc-sha1', 'arcfour-hmac'],
      description: `The enctypes used by krb5_server`
    },
    'gid': {
      $ref: 'module://@nikitajs/file/src/index#/properties/gid'
    },
    'keytab': {
      type: 'string',
      description: `Path to the file storing key entries.`
    },
    'mode': {
      $ref: 'module://@nikitajs/file/src/index#/properties/mode'
    },
    'password': {
      type: 'string',
      description: `Password associated to this principal; required if no randkey is
provided.`
    },
    'principal': {
      type: 'string',
      description: `Principal to be created.`
    },
    'realm': {
      type: 'string',
      description: `The realm the principal belongs to.`
    },
    'uid': {
      $ref: 'module://@nikitajs/file/src/index#/properties/uid'
    }
  },
  required: ['keytab', 'password', 'principal']
};

// ## Handler
handler = async function({
    config,
    tools: {log}
  }) {
  var _, cmd, code, enctype, entries, entry, i, j, k, kvno, len, len1, len2, line, match, mdate, princ, princ_entries, principal, ref, ref1, ref2, slot, status, stdout, timestamp, tmp_keytab, values;
  if (/^\S+@\S+$/.test(config.principal)) {
    if (config.realm == null) {
      config.realm = config.principal.split('@')[1];
    }
  } else {
    if (!config.realm) {
      throw Error('Property "realm" is required in principal');
    }
    config.principal = `${config.principal}@${config.realm}`;
  }
  entries = [];
  princ_entries = [];
  princ = {};
  cmd = null;
  // Get keytab entries
  ({status, stdout, code} = (await this.execute({
    cmd: `echo -e 'rkt ${config.keytab}\nlist -e -t \n' | ktutil`,
    code_skipped: 1,
    shy: true
  })));
  if (status) {
    log({
      message: "Principal exist in Keytab, check kvno validity",
      level: 'DEBUG',
      module: 'nikita/krb5/ktutil/add'
    });
    ref = utils.string.lines(stdout);
    for (i = 0, len = ref.length; i < len; i++) {
      line = ref[i];
      if (!(match = /^\s*(\d+)\s*(\d+)\s+([\d\/:]+\s+[\d\/:]+)\s+(.*)\s*\(([\w|-]*)\)\s*$/.exec(line))) {
        continue;
      }
      [_, slot, kvno, timestamp, principal, enctype] = match;
      kvno = parseInt(kvno, 10);
      entries.push({
        slot: slot,
        kvno: kvno,
        timestamps: timestamp,
        principal: principal.trim(),
        enctype: enctype
      });
    }
    princ_entries = entries.filter(function(e) {
      return `${e.principal}` === `${config.principal}`;
    }).reverse();
  }
  // Get principal information and compare to keytab entries kvnos
  ({status, stdout} = (await this.krb5.execute({
    admin: config.admin,
    cmd: `getprinc -terse ${config.principal}`,
    shy: true
  })));
  if (status) {
    values = utils.string.lines(stdout)[1];
    if (!values) {
      // Check if a ticket exists for this
      throw Error(`Principal does not exist: '${config.principal}'`);
    }
    values = values.split('\t');
    mdate = parseInt(values[2], 10) * 1000;
    kvno = parseInt(values[8], 10);
    princ = {
      mdate: mdate,
      kvno: kvno
    };
  }
  // read keytab and check kvno validities
  cmd = null;
  tmp_keytab = `${config.keytab}.tmp_nikita_${Date.now()}`;
  ref1 = config.enctypes;
  for (j = 0, len1 = ref1.length; j < len1; j++) {
    enctype = ref1[j];
    entry = princ_entries.filter(function(entry) {
      return entry.enctype === enctype;
    }).length === 1 ? entries.filter(function(entry) {
      return entry.enctype === enctype;
    })[0] : null;
    //entries.filter( (entry) -> entry.enctype is enctype).length is 1
    // add_entry_cmd = "add_entry -password -p #{config.principal} -k #{princ.kvno} -e #{enctype}\n#{config.password}\n"
    if ((entry != null) && ((entry != null ? entry.kvno : void 0) !== princ.kvno)) {
      if (cmd == null) {
        cmd = `echo -e 'rkt ${config.keytab}\n`;
      }
      // remove entry if kvno not identical
      log({
        message: `Remove from Keytab kvno '${entry.kvno}', principal kvno '${princ.kvno}'`,
        level: 'INFO',
        module: 'nikita/krb5/ktutil/add'
      });
      cmd += `delete_entry ${entry != null ? entry.slot : void 0}\n`;
    }
  }
  if (entries.length > princ_entries.length) {
    if (cmd != null) {
      await this.execute({
        cmd: cmd + `wkt ${tmp_keytab}\nquit\n' | ktutil`
      });
    }
    if (cmd != null) {
      await this.fs.move({
        source: tmp_keytab,
        target: config.keytab
      });
    }
  }
  if ((entries.length === princ_entries.length) && (cmd != null)) {
    await this.fs.remove({
      target: config.keytab
    });
  }
  // write entries in keytab
  cmd = null;
  ref2 = config.enctypes;
  for (k = 0, len2 = ref2.length; k < len2; k++) {
    enctype = ref2[k];
    entry = princ_entries.filter(function(entry) {
      return entry.enctype === enctype;
    }).length === 1 ? entries.filter(function(entry) {
      return entry.enctype === enctype;
    })[0] : null;
    if (((entry != null ? entry.kvno : void 0) !== princ.kvno) || (entry == null)) {
      if (cmd == null) {
        cmd = "echo -e '";
      }
      cmd += `add_entry -password -p ${config.principal} -k ${princ.kvno} -e ${enctype}\n${config.password}\n`;
    }
  }
  if (cmd != null) {
    await this.execute({
      cmd: cmd + `wkt ${config.keytab}\n' | ktutil`
    });
  }
  // Keytab ownership and permissions
  if ((config.uid != null) || (config.gid != null)) {
    await this.fs.chown({
      target: config.keytab,
      uid: config.uid,
      gid: config.gid
    });
  }
  if (!config.mode) {
    return;
  }
  return (await this.fs.chmod({
    target: config.keytab,
    mode: config.mode
  }));
};

// ## Export
module.exports = {
  handler: handler,
  metadata: {
    global: 'krb5'
  },
  schema: schema
};

// ## Fields in 'getprinc -terse' output

// princ-canonical-name
// princ-exp-time
// last-pw-change
// pw-exp-time
// princ-max-life
// modifying-princ-canonical-name
// princ-mod-date
// princ-attributes <=== This is the field you want
// princ-kvno
// princ-mkvno
// princ-policy (or 'None')
// princ-max-renewable-life
// princ-last-success
// princ-last-failed
// princ-fail-auth-count
// princ-n-key-data
// ver
// kvno
// data-type[0]
// data-type[1]

// ## Dependencies
utils = require('@nikitajs/engine/src/utils');

({mutate} = require('mixme'));
