// Generated by CoffeeScript 2.5.1
// # `nikita.docker.cp`

// Copy files/folders between a container and the local filesystem.

// Reflecting the original docker ps command usage, source and target may take
// the following forms:

// * CONTAINER:PATH 
// * LOCALPATH
// * process.readableStream as the source or process.writableStream as the
//   target (equivalent of "-")

// Note, stream are not yet supported.

// ## Options

// * `boot2docker` (boolean)   
//   Whether to use boot2docker or not, default to false.
// * `machine` (string)   
//   Name of the docker-machine, required if using docker-machine or boot2docker.
// * `source` (string)   
//   The path to upload or the container followed by the path to download.
// * `target` (string)   
//   The path to download or the container followed by the path to upload.

// ## Uploading a file

// ```javascript
// require('nikita')
// .docker({
//   source: readable_stream or '/path/to/source'
//   target: 'my_container:/path/to/target'
// }, function(err, {status}){
//   console.log( err ? err.message : 'Container copied' + status)
// )
// ```

// ## Downloading a file

// ```javascript
// require('nikita')
// .docker({
//   source: 'my_container:/path/to/source',
//   target: writable_stream or '/path/to/target'
// }, function(err, status){
//   console.log( err ? err.message : 'Container copied: ' + status);
// });
// ```

// ## Schema
var docker, handler, misc, path, schema;

schema = {
  type: 'object',
  properties: {}
};

// ## Handler
handler = function({
    config,
    log,
    operations: {find}
  }) {
  var _, k, ref, source_container, source_mkdir, source_path, ssh, target_container, target_mkdir, target_path, v;
  log({
    message: "Entering Docker cp",
    level: 'DEBUG',
    module: 'nikita/lib/docker/cp'
  });
  // SSH connection
  ssh = this.ssh(config.ssh);
  // Global config
  if (config.docker == null) {
    config.docker = {};
  }
  ref = config.docker;
  for (k in ref) {
    v = ref[k];
    if (config[k] == null) {
      config[k] = v;
    }
  }
  if (!config.source) {
    // Validate parameters
    throw Error('Missing option "source"');
  }
  if (!config.target) {
    throw Error('Missing option "target"');
  }
  [_, source_container, source_path] = /(.*:)?(.*)/.exec(config.source);
  [_, target_container, target_path] = /(.*:)?(.*)/.exec(config.target);
  if (source_container && target_container) {
    throw Error('Incompatible source and target config');
  }
  if (!source_container && !target_container) {
    throw Error('Incompatible source and target config');
  }
  source_mkdir = false;
  target_mkdir = false;
  // Source is on the host, normalize path
  this.call(function({}, callback) {
    if (source_container) {
      return callback();
    }
    if (/\/$/.test(source_path)) {
      source_path = `${source_path}/${path.basename(target_path)}`;
      return callback();
    }
    return this.fs.stat({
      ssh: config.ssh,
      target: source_path
    }, function(err, {stats}) {
      if (err && err.code !== 'ENOENT') {
        return callback(err);
      }
      if ((err != null ? err.code : void 0) === 'ENOENT') {
        // TODO wdavidw: seems like a mistake to me, we shall have source_mkdir instead
        return target_mkdir = true && callback();
      }
      if (misc.stats.isDirectory(stats.mode)) {
        source_path = `${source_path}/${path.basename(target_path)}`;
      }
      return callback();
    });
  });
  this.system.mkdir({
    target: source_path,
    if: function() {
      return source_mkdir;
    }
  });
  // Destination is on the host
  this.call(function({}, callback) {
    if (target_container) {
      return callback();
    }
    if (/\/$/.test(target_path)) {
      target_path = `${target_path}/${path.basename(target_path)}`;
      return callback();
    }
    return this.fs.stat({
      ssh: config.ssh,
      target: target_path
    }, function(err, {stats}) {
      if (err && err.code !== 'ENOENT') {
        return callback(err);
      }
      if ((err != null ? err.code : void 0) === 'ENOENT') {
        return target_mkdir = true && callback();
      }
      if (misc.stats.isDirectory(stats.mode)) {
        target_path = `${target_path}/${path.basename(target_path)}`;
      }
      return callback();
    });
  });
  this.system.mkdir({
    target: target_path,
    if: function() {
      return target_mkdir;
    }
  });
  return this.docker.tools.execute({
    cmd: `cp ${config.source} ${config.target}`
  }, docker.callback);
};

// ## Exports
module.exports = {
  handler: handler,
  schema: schema
};

// ## Dependencies
path = require('path');

docker = require('./utils');

misc = require('@nikitajs/core/lib/misc');
