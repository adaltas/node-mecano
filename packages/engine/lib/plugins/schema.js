// Generated by CoffeeScript 2.5.1
var Ajv, ajv_keywords, error, parse;

error = require('../utils/error');

Ajv = require('ajv');

ajv_keywords = require('ajv-keywords');

parse = function(uri) {
  var matches;
  matches = /^(\w+:)\/\/(.*)/.exec(uri);
  if (!matches) {
    throw error('SCHEMA_URI_INVALID_PROTOCOL', ['uri must start with a valid protocol', 'such as "module://" or "registry://",', `got ${uri}.`]);
  }
  return {
    protocol: matches[1],
    pathname: matches[2]
  };
};

module.exports = function({registry}) {
  var ajv, schema;
  ajv = new Ajv({
    $data: true,
    allErrors: true,
    useDefaults: true,
    // extendRefs: 'ignore'
    extendRefs: true,
    // coerceTypes: true
    loadSchema: function(uri) {
      return new Promise(function(accept, reject) {
        var action, module, pathname, protocol;
        ({protocol, pathname} = parse(uri));
        switch (protocol) {
          case 'module:':
            action = require.main.require(uri);
            return accept(action.schema);
          case 'registry:':
            module = pathname.split('/');
            action = registry.get(module);
            return accept(action.metadata.schema);
        }
      });
    }
  });
  ajv_keywords(ajv);
  schema = {
    add: function(schema, name) {
      if (!schema) {
        return;
      }
      return ajv.addSchema(schema, name);
    },
    validate: async function(data, schema) {
      var valid, validate;
      validate = (await ajv.compileAsync(schema));
      valid = validate(data);
      if (validate.errors) {
        return validate.errors.map(function(error) {
          return Error(ajv.errorsText([error]));
        });
      } else {
        return [];
      }
    },
    list: function() {
      return {
        schemas: ajv._schemas,
        refs: ajv._refs,
        fragments: ajv._fragments
      };
    }
  };
  return {
    'nikita:session:normalize': function({action}, handler) {
      return function({action, context}) {
        action = handler.call(context, {
          action: action,
          context: context
        });
        action.schema = schema;
        return action;
      };
    },
    'nikita:session:handler:call': async function({action}, handler) {
      var errors;
      if (!action.metadata.schema) {
        return handler;
      }
      errors = (await schema.validate(action.options, action.metadata.schema));
      if (errors.length) {
        if (errors.length === 1) {
          error = errors[0];
        } else {
          error = new Error(`Invalid Options: got ${errors.length} errors\n${errors.map(function(error) {
            return error.message;
          }).join('\n')}`);
          error.errors = errors;
        }
        error.options = action.options;
        error.metadata = action.metadata;
        throw error;
      }
      return handler;
    }
  };
};
