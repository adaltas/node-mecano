// Generated by CoffeeScript 2.5.1
var args_to_actions, merge, plugins, registry, run, schedule, session;

({merge} = require('mixme'));

registry = require('./registry');

schedule = require('./schedule');

plugins = require('./plugins');

args_to_actions = require('./args_to_actions');

session = function(action = {}) {
  var on_call, on_get, result;
  // Catch calls to new actions
  on_call = function() {
    var args, namespace, prom;
    // Extract action namespace and reset the state
    namespace = action.state.namespace.slice();
    action.state.namespace = [];
    args = arguments;
    prom = action.scheduler.add(function() {
      // Validate the namespace
      if (!action.registry.registered(namespace)) {
        return Promise.reject(Error(`No action named ${JSON.stringify(namespace.join('.'))}`));
      }
      return action.run(...args, {
        metadata: {
          namespace: namespace
        }
      });
    });
    return new Proxy(prom, {
      get: on_get
    });
  };
  // Building the namespace before calling an action
  on_get = function(target, name) {
    if ((target[name] != null) && !action.registry.get(name)) {
      if (typeof target[name] === 'function') {
        return target[name].bind(target);
      } else {
        return target[name];
      }
    }
    if (action.state.namespace.length === 0) {
      switch (name) {
        case 'plugins':
          return action.plugins;
      }
    }
    action.state.namespace.push(name);
    return new Proxy(on_call, {
      get: on_get
    });
  };
  // Initialize the registry to manage action registration
  action.registry = registry.create({
    parent: action.parent ? action.parent.registry : registry,
    on_register: async function(name, act) {
      return (await action.plugins.hook({
        name: 'nikita:registry:action:register',
        args: {
          name: name,
          action: act
        }
      }));
    }
  });
  // Initialize the plugins manager
  action.plugins = plugins({
    plugins: action.plugins,
    chain: new Proxy(on_call, {
      get: on_get
    }),
    parent: action.parent ? action.parent.plugins : void 0,
    action: action
  });
  // Local scheduler
  action.scheduler = schedule();
  // Register run helper
  action.run = function() {
    return run({
      metadata: {
        depth: action.metadata.depth + 1
      },
      parent: action
    }, ...arguments);
  };
  setImmediate(function() {
    return action.scheduler.pump();
  });
  // Execute the action
  result = new Promise(async function(resolve, reject) {
    var action_from_registry, context, err, on_end, output;
    // Make sure the promise is resolved after the scheduler and its children
    on_end = new Promise(function(resolve, reject) {
      return action.scheduler.on_end(function() {
        return resolve();
      });
    });
    // Hook attented to modify the current action being created
    action = (await action.plugins.hook({
      name: 'nikita:session:normalize',
      args: {
        action: action
      },
      handler: function({action}) {
        action = args_to_actions.normalize(action);
        return action;
      }
    }));
    // Load action from registry
    if (action.metadata.namespace) {
      action_from_registry = action.registry.get(action.metadata.namespace);
      // Merge the registry action with the user action properties
      action = merge(action_from_registry, action);
    }
    context = new Proxy(on_call, {
      get: on_get
    });
    action.context = context;
    try {
      // Hook attented to alter the execution of an action handler
      output = action.plugins.hook({
        name: 'nikita:session:handler:call',
        args: {
          context: context,
          action: action
        },
        handler: function({context, action}) {
          return action.handler.call(context, action);
        }
      });
      if (!(output && output.then)) {
        output = new Promise(function(resolve, reject) {
          return resolve(output);
        });
      }
      return Promise.all([output, on_end]).then(function(values) {
        return resolve(values.shift());
      }, function(err) {
        return reject(err);
      });
    } catch (error) {
      err = error;
      return reject(err);
    }
  });
  // Returning a proxified promise:
  // - news action can be registered to it as long as the promised has not fulfilled
  // - resolve when all registered actions are fulfilled
  // - resolved with the result of handler
  return new Proxy(result, {
    get: on_get
  });
};

module.exports = run = function(...args) {
  var actions, args_is_array, proms;
  // Are we scheduling multiple actions
  args_is_array = args.some(function(arg) {
    return Array.isArray(arg);
  });
  actions = args_to_actions.build([
    {
      state: {
        namespace: []
      }
    },
    ...args
  ]);
  proms = actions.map(function(action) {
    return session(action);
  });
  if (args_is_array) {
    return Promise.all(proms);
  } else {
    return proms[0];
  }
};
