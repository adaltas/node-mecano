// Generated by CoffeeScript 2.5.1
var error;

error = require('./utils/error');

module.exports = function() {
  var events, running, scheduler, stack;
  stack = [];
  running = false;
  events = {
    end: []
  };
  return scheduler = {
    on_end: function(resolve, reject) {
      events.end.push({
        resolve: resolve,
        reject: reject
      });
      return this;
    },
    pump: function() {
      var handler, i, len, prom, ref, reject, resolve, results;
      if (running) {
        return;
      }
      if (stack.length) {
        running = true;
        [handler, resolve, reject] = this.next();
        return setImmediate(function() {
          var handlers, res;
          res = handler.call();
          if (Array.isArray(res)) {
            running = false;
            handlers = res;
            scheduler.add(handlers).then(resolve, reject);
            return setImmediate(function() {
              return scheduler.pump();
            });
          } else if (res.then) {
            return res.then(function() {
              // console.log 'pump done', running, stack.length
              running = false;
              resolve.apply(handler, arguments);
              return setImmediate(function() {
                return scheduler.pump();
              });
            }, function(err) {
              // console.log 'pump done', running, stack.length
              running = false;
              reject(err);
              return setImmediate(function() {
                return scheduler.pump();
              });
            });
          } else {
            // for prom in events.end
            //   {reject} = prom
            //   reject.call()
            throw error('SCHEDULER_INVALID_HANDLER', ['scheduled handler must return a promise or an array of handlers,', `got ${JSON.stringify(res)}`]);
          }
        });
      } else {
        ref = events.end;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          prom = ref[i];
          ({resolve} = prom);
          results.push(resolve.call());
        }
        return results;
      }
    },
    next: function() {
      return stack.shift();
    },
    clear: function() {
      return stack = [];
    },
    add: function(handlers, options = {}) {
      var prom;
      prom = new Promise(function(resolve, reject) {
        var dir, handler, promises;
        dir = options.first ? 'unshift' : 'push';
        if (!Array.isArray(handlers)) {
          stack[dir]([handlers, resolve, reject]);
        } else {
          promises = (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = handlers.length; i < len; i++) {
              handler = handlers[i];
              results.push(new Promise(function(resolve, reject) {
                return stack[dir]([handler, resolve, reject]);
              }));
            }
            return results;
          })();
          Promise.all(promises).then(resolve, reject);
        }
        // Pump execution
        return setImmediate(function() {
          if (options.force) {
            running = false;
          }
          return scheduler.pump();
        });
      });
      return prom;
    }
  };
};
