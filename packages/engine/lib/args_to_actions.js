// Generated by CoffeeScript 2.5.1
var array, is_object, merge, multiply, mutate, properties, properties_metadata, properties_root, reconstituate, values, ventilate,
  indexOf = [].indexOf;

({is_object, merge, mutate} = require('mixme'));

array = require('./misc/array');

module.exports = function(args) {
  var actions;
  actions = multiply(args);
  actions = reconstituate(actions);
  actions = ventilate(actions);
  actions = values(actions);
  return actions;
};

module.exports.build = function(args) {
  var actions;
  actions = multiply(args);
  actions = reconstituate(actions);
  return actions;
};

module.exports.normalize = function(actions) {
  actions = ventilate(actions);
  actions = values(actions);
  return actions;
};

module.exports.multiply = multiply = function(args) {
  var action, actions, arg, arg_element, i, j, k, l, len, len1, newactions;
// Convert every argument to an array
  for (i = k = 0, len = args.length; k < len; i = ++k) {
    arg = args[i];
    if (!Array.isArray(arg)) {
      args[i] = [arg];
    }
  }
  // Multiply arguments
  actions = [];
  for (i = l = 0, len1 = args.length; l < len1; i = ++l) {
    arg = args[i];
    newactions = (function() {
      var len2, m, results;
      results = [];
      for (j = m = 0, len2 = arg.length; m < len2; j = ++m) {
        arg_element = arg[j];
        // Every element of the first argument will initialize actions
        if (i === 0) {
          results.push([[arg_element]]);
        } else {
          results.push((function() {
            var len3, n, results1;
            results1 = [];
            for (i = n = 0, len3 = actions.length; n < len3; i = ++n) {
              action = actions[i];
              results1.push([...action, arg_element]);
            }
            return results1;
          })());
        }
      }
      return results;
    })();
    actions = array.flatten(newactions, 0);
  }
  return actions;
};

module.exports.reconstituate = reconstituate = function(actions) {
  var action, arg, k, l, len, len1, new_action, results;
  results = [];
  for (k = 0, len = actions.length; k < len; k++) {
    action = actions[k];
    new_action = {};
    for (l = 0, len1 = action.length; l < len1; l++) {
      arg = action[l];
      switch (typeof arg) {
        case 'function':
          if (action.handler) {
            throw Error('Invalid Action Argument: handler is already registered, got a function');
          }
          mutate(new_action, {
            handler: arg
          });
          break;
        case 'string':
          if (action.handler) {
            throw Error(`Invalid Action Argument: handler is already registered, got ${JSON.stringigy(arg)}`);
          }
          mutate(new_action, {
            metadata: {
              argument: arg
            }
          });
          break;
        case 'object':
          if (Array.isArray(arg)) {
            throw Error(`Invalid Action argument: argument cannot be an array, got ${JSON.stringify(arg)}`);
          }
          if (arg === null) {
            mutate(new_action, {
              metadata: {
                argument: null
              }
            });
          } else {
            mutate(new_action, arg);
          }
          break;
        default:
          mutate(new_action, {
            metadata: {
              argument: arg
            }
          });
      }
    }
    results.push(new_action);
  }
  return results;
};

module.exports.ventilate = ventilate = function(action) {
  var new_action, property, value;
  if (Array.isArray(action)) {
    return action.map(function(action) {
      return ventilate(action);
    });
  }
  new_action = {
    metadata: action.metadata || {},
    options: action.options || {}
  };
  for (property in action) {
    value = action[property];
    if (property === 'metadata') {
      continue; // Already merged before
    } else if (property === 'options') {
      continue; // Already merged before
    } else if (indexOf.call(properties_root, property) >= 0) {
      new_action[property] = value;
    } else if (indexOf.call(properties_metadata, property) >= 0) {
      new_action.metadata[property] = value;
    } else {
      new_action.options[property] = value;
    }
  }
  return new_action;
};

module.exports.values = values = function(action) {
  var base, property, ref, value;
  if (Array.isArray(action)) {
    return action.map(function(action) {
      return values(action);
    });
  }
  ref = properties.metadata;
  for (property in ref) {
    value = ref[property];
    if ((base = action.metadata)[property] == null) {
      base[property] = value;
    }
  }
  return action;
};

module.exports.properties = properties = {
  context: void 0,
  handler: null,
  metadata: {
    // address: null
    namespace: [],
    after: null,
    argument: null,
    attempt: -1,
    before: null,
    cascade: {},
    debug: false,
    deprecate: false,
    depth: 0,
    disabled: false,
    get: false,
    header: [],
    log: null,
    once: false,
    relax: false,
    retry: 0,
    schema: null,
    shy: false,
    sleep: 3000,
    status: true,
    tolerant: false
  },
  parent: null,
  registry: null,
  options: {},
  plugins: void 0,
  scheduler: void 0,
  state: {
    namespace: []
  },
  run: void 0
};

properties_root = Object.keys(properties);

properties_metadata = Object.keys(properties.metadata);
