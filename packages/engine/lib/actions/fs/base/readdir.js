// Generated by CoffeeScript 2.5.1
// # `nikita.fs.readdir(options, callback)`

// Reads the contents of a directory. The implementation is conformed with the
// Node.js native
// [`fs.readir`](https://nodejs.org/api/fs.html#fs_fs_readdir_path_options_callback)
// function.

// ## Output parameters

// * `files` ([fs.Dirent])   
//   List of the names of the files in the directory excluding '.' and '..'

// ## Examples

// Return an array of files if only the target options is provided:

// ```js
// require('nikita')
// .fs.mkdir('/parent/dir/a_dir')
// .fs.writeFile('/parent/dir/a_file', '')
// .fs.readdir("/parent/dir/a_dir", function(err, {files}){
//   assert(files, ['my_dir', 'my_file'])
// })
// ```

// Return an array of `Dirent` objects if the `withFileTypes` options is provided:

// ```js
// require('nikita')
// .fs.writeFile('/parent/dir/a_file', '')
// .fs.readdir({
//   target: "/parent/dir/a_dir",
//   withFileTypes: true
// }, function(err, {files}){
//   assert(files[0].name, 'a_file'
//   assert(files[0].isFile(), true)
// })
// ```

// ## Hook
var Dirent, NIKITA_FS_READDIR_TARGET_ENOENT, constants, error, errors, handler, lines, on_action, schema;

on_action = function({config, metadata}) {
  if (metadata.argument != null) {
    config.target = metadata.argument;
  }
  if (config.withFileTypes != null) {
    return config.extended != null ? config.extended : config.extended = config.withFileTypes;
  }
};

// ## Schema
schema = {
  type: 'object',
  properties: {
    extended: {
      type: 'boolean',
      description: `Result contain fs.Dirent objects.`
    },
    target: {
      type: 'string',
      description: `Path of the directory to read;`
    },
    withFileTypes: {
      type: 'boolean',
      description: `Alias of \`extended\` named after the Node.js native function.`
    }
  },
  required: ['target']
};

// ## Source Code
handler = async function({config}) {
  var err, opts, stdout;
  this.log({
    message: "Entering fs.readdir",
    level: 'DEBUG',
    module: 'nikita/lib/fs/readdir'
  });
  // Note: -w work on macos, not on linux, it force raw printing of
  // non-printable characters. This is the default when output is not to a
  // terminal.
  opts = [
    '1', // (The numeric digit ``one''.)  Force output to be one entry per line.  This is the default when output is not to a terminal.
    'a', // Include directory entries whose names begin with a dot (.)
    config.extended ? 'n' : void 0, // Display user and group IDs numerically, rather than converting to a user or group name in a long (-l) output.  This option turns on the -l option.
    config.extended ? 'l' : void 0
  ].join('');
  try {
    // List the directory
    ({stdout} = (await this.execute({
      cmd: `[ ! -d '${config.target}' ] && exit 2
ls -${opts} ${config.target}`
    })));
    return {
      // Convert the output into a `files` array
      files: lines(stdout).filter(function(line, i) {
        return !config.extended || i !== 0; // First line in extended mode
      }).filter(function(line) {
        return line !== ''; // Empty lines
      }).map(function(line, i) {
        var name, perm;
        if (!config.extended) {
          return {
            name: line
          };
        } else {
          [, perm, , name] = /^(.+?)\s+.*?(\d+:\d+)\s+(.+)$/.exec(line);
          return {
            name: name,
            type: (function() {
              switch (perm[0]) {
                case 'b':
                  return constants.UV_DIRENT_BLOCK; // Block special file.
                case 'c':
                  return constants.UV_DIRENT_CHAR; // Character special file.
                case 'd':
                  return constants.UV_DIRENT_DIR; // Directory.
                case 'l':
                  return constants.UV_DIRENT_LINK; // Symbolic link.
                case 's':
                  return constants.UV_DIRENT_SOCKET; // Socket link.
                case 'p':
                  return constants.UV_DIRENT_FIFO; // FIFO.
                default:
                  return constants.UV_DIRENT_FILE; // Regular file.
              }
            })()
          };
        }
      }).filter(function({name}) {
        return name !== '' && name !== '.' && name !== '..';
      }).map(function(file) {
        if (config.extended) {
          return new Dirent(file.name, file.type);
        } else {
          return file.name;
        }
      })
    };
  } catch (error1) {
    err = error1;
    if (err.exit_code === 2) {
      throw NIKITA_FS_READDIR_TARGET_ENOENT({
        config: config,
        err: err
      });
    } else {
      throw err;
    }
    throw err;
  }
};

// ## Exports
module.exports = {
  handler: handler,
  hooks: {
    on_action: on_action
  },
  metadata: {
    log: false,
    raw_output: true
  },
  schema: schema
};

// ## Errors
errors = NIKITA_FS_READDIR_TARGET_ENOENT = function({config, err}) {
  return error('NIKITA_FS_READDIR_TARGET_ENOENT', ['fail to read a directory, target is not a directory,', `got ${JSON.stringify(config.target)}`], {
    exit_code: err.exit_code,
    errno: -2,
    syscall: 'rmdir',
    path: config.target
  });
};


  // ## Dependencies
({lines} = require('../../../utils/string'));

error = require('../../../utils/error');

({Dirent, constants} = require('fs'));
