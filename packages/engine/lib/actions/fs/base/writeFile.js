// Generated by CoffeeScript 2.5.1
// # `nikita.fs.writeFile`

// Write a Buffer or a string to a file. This action mimic the behavior of the
// Node.js native [`fs.writeFile`](https://nodejs.org/api/fs.html#fs_fs_writefile_file_data_options_callback)
// function.

// Internally, it uses the `nikita.fs.createWriteStream` from which it inherits all
// the configuration properties.

// ## Example

// ```
// require('nikita')
// .fs.writeFile({
//   target: "#{scratch}/a_file",
//   content: 'Some data, a string or a Buffer'
// })
// ```

// ## Hook
var errors, handler, on_action, schema;

on_action = function({config, metadata}) {
  if (metadata.argument != null) {
    return config.target = metadata.argument;
  }
};

// ## Schema
schema = {
  type: 'object',
  properties: {
    'content': {
      oneOf: [
        {
          type: 'string'
        },
        {
          instanceof: 'Buffer'
        }
      ],
      description: `Content to write.`
    },
    'cwd': {
      type: 'string',
      description: `Current working directory used to resolve a relative target path.`
    },
    'flags': {
      type: 'string',
      default: 'w',
      description: `File system flag as defined in the [Node.js
documentation](https://nodejs.org/api/fs.html#fs_file_system_flags)
and [open(2)](http://man7.org/linux/man-pages/man2/open.2.html)`
    },
    'target_tmp': {
      type: 'string',
      description: `Location where to write the temporary uploaded file before it is
copied into its final destination, default to
"{tmpdir}/nikita_{YYMMDD}_{pid}_{rand}/{hash target}"`
    },
    'mode': {
      oneOf: [
        {
          type: 'integer'
        },
        {
          type: 'string'
        }
      ],
      // default: 0o644
      description: `Permission mode, a bit-field describing the file type and mode.`
    },
    'target': {
      oneOf: [
        {
          type: 'string'
        },
        {
          instanceof: 'Buffer'
        }
      ],
      description: `Final destination path.`
    }
  },
  required: ['content', 'target']
};

// ## Handler
handler = function({
    config,
    operations: {path},
    ssh
  }) {
  this.log({
    message: "Entering fs.writeFile",
    level: 'DEBUG',
    module: 'nikita/lib/fs/writeFile'
  });
  // Normalization
  config.target = config.cwd ? path.resolve(config.cwd, config.target) : path.normalize(config.target);
  if (ssh && !path.isAbsolute(config.target)) {
    throw NIKITA_FS_STAT_TARGET_ENOENT({
      config: config,
      err: err
    });
  }
  // Real work
  return this.fs.base.createWriteStream({
    target: config.target,
    flags: config.flags,
    mode: config.mode,
    stream: function(ws) {
      ws.write(config.content);
      return ws.end();
    }
  });
};

// ## Errors
errors = {
  NIKITA_FS_STAT_TARGET_ENOENT: function({config, err}) {
    return error('NIKITA_FS_TARGET_INVALID', ['the target location is absolute', 'but this is not suported in SSH mode,', 'you must provide an absolute path or the cwd option,', `got ${JSON.stringify(config.target)}`], {
      exit_code: err.exit_code,
      errno: -2,
      syscall: 'rmdir',
      path: config.target
    });
  }
};

// ## Exports
module.exports = {
  handler: handler,
  hooks: {
    on_action: on_action
  },
  metadata: {
    log: false,
    raw_output: true
  },
  schema: schema
};
