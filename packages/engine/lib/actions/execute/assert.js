// Generated by CoffeeScript 2.5.1
  // # `nikita.execute.assert`

// Assert the execution or the output of a command.

// ## Configuration

// All configuration properties are passed to `nikita.execute`.

// ## Assert a command succeed

// ```javascript
  // nikita.execute.assert({
  //   cmd: 'exit 0'
  // }, function(err){
  //   console.info(err || 'ok');
  // });
  // ```

// ## Assert a command stdout

// ```javascript
  // nikita.execute.assert({
  //   cmd: 'echo hello'
  //   assert: 'hello'
  // }, function(err){
  //   console.info(err || 'ok');
  // });
  // ```

// ## Hook
var error, handler, on_action, regexp, schema,
  indexOf = [].indexOf;

on_action = function({config, metadata}) {
  if (!config.content) {
    // config.cmd = metadata.argument if metadata.argument?
    if (config.code == null) {
      config.code = [0];
    }
  }
  if ((config.code != null) && !Array.isArray(config.code)) {
    return config.code = [config.code];
  }
};

// ## Schema
schema = {
  type: 'object',
  properties: {
    'code': {
      type: 'array',
      // default: [0]
      items: {
        type: 'integer'
      },
      description: `Expected exit code, activated by default unless content is provided.`
    },
    'content': {
      onfOf: [
        {
          type: 'string'
        },
        {
          instanceof: 'Buffer'
        },
        {
          instanceof: 'RegExp'
        }
      ],
      description: `Content to match, optional.`
    },
    'error': {
      type: 'string',
      description: `The error message to throw if assert failed.`
    },
    'not': {
      type: 'boolean',
      default: false,
      description: `Negates the validation.`
    },
    'trim': {
      type: 'boolean',
      default: false,
      description: `Trim the expected content as well as the command output before
matching.`
    }
  }
};

// ## Handler
handler = async function({config}) {
  var code, res, stdout;
  if (Buffer.isBuffer(config.content)) {
    config.content = config.content.toString();
  }
  if (config.content && config.trim) {
    config.content = config.content.trim();
  }
  // Command exit code
  if (config.code != null) {
    ({code} = (await this.execute(config, {
      relax: true
    })));
    if (!config.not) {
      if (indexOf.call(config.code, code) < 0) {
        throw error('NIKITA_EXECUTE_ASSERT_EXIT_CODE', ['an unexpected exit code was encountered,', `got ${JSON.stringify(code)}`, config.code.length === 1 ? `while expecting ${config.code}.` : `while expecting one of ${JSON.stringify(config.code)}.`]);
      }
    } else {
      if (indexOf.call(config.code, code) >= 0) {
        throw error('NIKITA_EXECUTE_ASSERT_NOT_EXIT_CODE', ['an unexpected exit code was encountered,', `got ${JSON.stringify(code)}`, config.code.length === 1 ? `while expecting anything but ${config.code}.` : `while expecting anything but one of ${JSON.stringify(config.code)}.`]);
      }
    }
  }
  // Content is a string or a buffer
  if ((config.content != null) && typeof config.content === 'string') {
    res = (await this.execute(config));
    ({stdout} = res);
    if (config.trim) {
      stdout = stdout.trim();
    }
    if (!config.not) {
      if (stdout !== config.content) {
        throw error('NIKITA_EXECUTE_ASSERT_CONTENT', ['the command output is not matching the content,', `got ${JSON.stringify(stdout)}`, `while expecting to match ${JSON.stringify(config.content)}.`]);
      }
    } else {
      if (stdout === config.content) {
        throw error('NIKITA_EXECUTE_ASSERT_NOT_CONTENT', ['the command output is unfortunately matching the content,', `got ${JSON.stringify(stdout)}.`]);
      }
    }
  }
  // Content is a regexp
  if ((config.content != null) && regexp.is(config.content)) {
    ({stdout} = (await this.execute(config)));
    if (config.trim) {
      stdout = stdout.trim();
    }
    if (!config.not) {
      if (!config.content.test(stdout)) {
        throw error('NIKITA_EXECUTE_ASSERT_CONTENT_REGEX', ['the command output is not matching the content regexp,', `got ${JSON.stringify(stdout)}`, `while expecting to match ${JSON.stringify(config.content)}.`]);
      }
    } else {
      if (config.content.test(stdout)) {
        throw error('NIKITA_EXECUTE_ASSERT_NOT_CONTENT_REGEX', ['the command output is unfortunately matching the content regexp,', `got ${JSON.stringify(stdout)}`, `matching ${JSON.stringify(config.content)}.`]);
      }
    }
  }
};

// ## Exports
module.exports = {
  handler: handler,
  hooks: {
    on_action: on_action
  },
  schema: schema
};

// ## Dependencies
error = require('../../utils/error');

regexp = require('../../utils/regexp');
